<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Shadama: A Particle Simulation Programming Environment</title>
    <link rel="stylesheet" href="tufte.css"/>
    <link rel="stylesheet" href="latex.css"/>
    <link rel="stylesheet" href="style.css"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>

  <body>
    <article>
      <h1 id="title">Shadama: A Particle Simulation Programming Environment</h1>
      <p class="subtitle">Yoshiki Ohshima, Dan Amelang and Bert Freudenberg<br>
      HARC/Y Combinator Research</p>

      <section id="abstract">
        <p>abstract goes here</p>
      </section>

      <section>
        <h2>Introduction</h2>
        <p>
The computing power that is available for each of us in the world is
astounding.  Achiving the Teraflops mark was a milestone for
building-sized supercomputers in late '90's.  Now, a smartphone has
equivalent performance.
	</p>
	<p>
But what are people doing with it?  I don't want to say bad stuff
about my friends and families, but they are watching cat videos and
playing solitaire, not trying to invent self-flying personal
airplaces, or to discover graviton.  A joke aside, one big problem we
face today is that the importance of science literacy seems to be
discounted, when we will need the next generationto to embrace science
more not less.
	</p>
	<p>
We think this is a good time to restart our efforts to provide an
environment where school students, artsts, and even professional
programmers can tap into the power provided by hardware easily.
	</p>
	<p>
In this effort, we have been working on a prototype of a programming
language intended for high school students to explore scientific
ideas.
	</p>
	<p>
Science is about making invisible things visible.  One notable example
is molecules.  We would like students to learn about them through
actual experiments, and then, build models to understand it.  By
taking advantage of the power of computer, they should be able to make
a dynamic model with massive number of particles, and interactively
explore the idea.
	</p>
	<p>
So we set ourselves out to make a prototype of the language.  We set following goals:
<ul>
<li> Object-Oriented.
<li> Large number of objects
<li> Liveness. 
</ul>

       <p>
The object-orientation helps the user to focus on the behavior of one
particle, following what they might already know about Scratch or
similar languages.  This is the tradition from StarLogo, where large
number of objects are organized in breeds of turtles and patches, but
mostly the programmer begins with writing simple of actions for one
turtle.
       </p>
       <p>
For the second point, there is a trade of between performance and
language semantics.  On one hand, we want to be able to write a
program that controls millions of objects.  On one hand, we would like
an end-user language to be free from the constraints imposed by
particular nature of hardware.  On the other hand, however, there are
some fundamental limitations the execution model has to follow to gain
any performance benefit from GPU.  In particular, sharing turtles' own
states directly with others, or dynamically constructing a list of
turtles in its neighborhood, are not implementable in GPU.  But we
found that the indirect communication scheme facilitated by patches
mitigates the limitation.
       </p>
       <p>
For the third point, the environment should show the effects of user
actions, in this case code changes, as soon as possible in principle.
However, Shadama aspires to an environment where the simulation is
already live, and code change should not restart the simulation, we
found that the user rather want to wait until a
<i>chunk of meaningful code change</i>
is completed before the system adapt to a partial change too quickly.
An example of a meaningful chunk is changing the arity of a function: it is not sensible to run the
program until both the function definition and its caller have been
changed.  After changing those locations, the user can make a minimum gesture (such as hitting Cmd-S for
save), and the change takes effects immediately.
       </p>
</section>
<section>
	<h2 id="a-science-experiment">A Science Experiment</h2>
	  <p>
We begins with an actual science experiment to motivate the narrative.
This movie shows a vacuum cannon.  The vacuum cannon is a six foot PVC
pipe, connected to a vacuum pump.  We put a ping pong ball inside,
cover the open ends with a soft and sturdy but breakable material such
as plastic cake plates, and pump the air out.  In this movie the
inside was about 20% of the atmospheric pressure.
	  </p>
<iframe width="640" height="360" src="https://www.youtube.com/embed/07D0nB3mgLA" frameborder="0" allowfullscreen></iframe>
	  <p>
When one end near the ping pong ball is popped by a box cutter, the
air molecules that are moving toward the opening keep moving into the
low pressure space, and the ping pong ball is simply pushed out
because of it.  Our crude version can achieve over 200 meters/sec,
which is about 60% of the speed of sound.  Some people have built one
that can achieve super sonic speed.
	</p>
        <p>
Recall that the idea that science is about making invisible visible.
The important point to understand is that it is just movement of
molecules that is is causing the ball to shoot away.  With this in
mind we would like to have an environment where students can actually
do the experiment in the real world and then make a simulation of it.
	  </p>
</section>
<section>
	<h2 id="shadama-in-Action">Shadama in Action</h2>
<iframe width="1024" height="576" src="https://www.youtube.com/embed/g4rloq5FRLM" frameborder="0" allowfullscreen></iframe>
	<p>
The following text is the explanation of the movie.  We should be able to have the narrative going but if not, please have two screens, and view the movie in full screen and see the text below.
	</p>
	<p>
Here we try to make a simple physics simulation where many particles
are following some gravity law.
	</p>
	<p>
In a Shadama program, we declare a breed of turtles.  Here, the breed
called Turtle has x, y, r, g, b and a properties.  A method is defined
with the keyword "def".  Method is executed on each turtle in a breed.
The setColor method uses the turtle's x and y coordinate and assign
them into r and g.
	</p>
	<p>
In a static function called "setup", we first set the number of
turtles in the breed to be 3,000, set all turtle's x and y to be a
random number between 0 and 512.  We run it by hitting Cmd-S, and it
runs.  But we don't see the result until we call the setColor method,
and call the draw primitive.
	</p>
	<p>
Those dots are hard to see, but we can increase the number of turtles
to 30,000, 300,000 and 1 million.
	</p>
	<p>
What we want to do next is to move those turtles around.  So we define
a method called move.  Move increments the x and y of turtles.  I call
the move method from a static function step, and draw turtles.  When I
set the clock on step and repeatedly execute it, the turtles move.
	</p>
	<p>
Interestingly, while they are moving, I can edit the program on the
fly and the changes takes effect as soon as I hit Cmd-S.  I can add an
argument to move, use it in the code, change the call site and the
turtles that went off screen comes back.
	</p>
	<p>
We would actually like each individual turtle to have its own
velocity, so we add dx and dy to each turtle.  And then use them in
move.  Here, instead of n, we increment x and y of each turtle with
their dx and dy.
	</p>
	<p>
We add a primitive to set the x and y component of a random direction
vector, and run the code.  Now, all turtles move to their own
directions.  Try again by executing setup, We are trying make a
gravity simulation, so we add constant acceleration to the y component
of the velocity.  Now all turtles are accelerated toward the bottom.
	</p>
	<p>
But we don't want those particles to go out of bounds.  So we extend
the move method.  First we store dx and dy, as well as the possible
new location of x and y into local variables.  when newX is going out
of bounds, we make the turtle bounce back.  When newY is going below,
we wrap the turtle around to the top.  After adjusting those values,
we write those values back to turtle's properties.  Now one million
turtles are falling down, bouncing off the side walls, and wrap around
to the top.
	</p>
	<p>
We are going add some large objects.  To do so, we use a grid of data
cells called patches.  A patch is a set of 2D grid cells where turtles
can store values.  Here, we create a patch called Field, and a breed
called Filler that operates on it.
	</p>
	<p>
We define a method called fill.  This method takes an argument, and
updates fields, values.  And the setup uses a primitive called
fillSpace, which create enough number of turtles in the breed and
locate them at all integral grid point.  When this setup is called,
and the fill method is called for all turtles in the Filler breed, the
patch's r and g gets this gradation.
	</p>
	<p>
But instead of gradation, let us make some shapes.  So we define
fillCircle method instead.  The idea of fillCircle is that each turtle
checks whether it is within the radius, and only when it is, it writes
values into the cell.  We define the clear method, and now we use them
in setup.  We get a circle at (100, 100).
	</p>
	<p>
We can actually make the program interactive.  Split the setup
function and create another one called loop.  Notice that there is a
variable called mousemove, which updates when you move the mouse
pointer in the display.  That is an indication that we can use the
value in our program.
	</p>
	<p>
Now let us tie all together.  This code has some of the methods we
used previously, such as setColor.  fillCircle is slightly modified so
that it sets the normal vector for the circle.  In move, each turtle
checks the normal in the cell where the turtle is at, computes the new
direction that uses the dot product.  When I run this, particles are
bouncing off the circle as expected.
	</p>
	<p>
However, it is a bit hard to see because the colors of turtles are too
close.  Here, we change the setColor method so that instead of the x,
and y position, it uses the dx and dy to decides its color.  Then we
call setColor from loop, so that it updates its color all the time.
	</p>
	<p>
Here, horizontal velocity is rendered as reddish color, and vertical
velocity is rendered as greenish color.  As you can see, you can
change the visualization quickly and observe the simulation in a way
you like.
	</p>
	<p>
For fun, you can make two circles that moves symmetrically.
	</p>
	<p>
This is a variation of this program.  I replace the code.  Here,
instead of modeling the gravity pulling downward, the gravity follow
the inverse square law from the mouse pointer's location.  It appears
that there is large structure, but the truth is that it is just
quarter million particles had a regular initial condition, and
following the inverse square law.
	</p>
	<p>
Shadama allows the user to import an image.  The primitive fillImage
takes an image object, and creates enough turtles and set their colors
based on the images pixel values.  This looks like an image but it
actually a set of turtles.  We define the same move method, set the
direction vector to random directions, an run the function.  For fun,
if you use the r and g channel values for the velocity, you can make
an interesting effect.
	</p>
	<p>
WE can try some mathematical functions.  This is a program to
visualize the mandelbrot set, We can change the color scheme on the
fly for example.
	</p>
	<p>
And, this is the Game of Life.  Again, we can change the program while
the simulation is running, and the code change is reflected to the
simulation right away, without needing to restart it.
	</p>
</section>
<section>
	<h2 id="related-work">Related Work</h2>
	<p>
The major inspiration is Resnick's StarLogo.  The basic organization
of Shadama objects is largely drawn upon StarLogo, and in fact Shadama
is missing some key features to access other turtles from a turtle.
	</p>
	<p>
Lately, there are various simulation environments, such as Liquid Fun,
various Box2D based environments.  Nicky Case has a simulation
construction environment based on emoji.  As of now, Shadama uses a
textual language, based on the observation that physics simulations
often only takes concise problem description so coding part is not the
major obstacle.
	</p>
</section>
<section>
	<h2 id="conclusions-and-future-work">Conclusions and Future Work</h2>
	<p>
This is an early prototype of the concept of a simulation language in
which users can make simulations, interactive art and various
visualization.  The liveliness of the environment encourages the
exploratory style of programming, that is handy to try different ideas
quickly.  An anecdotal observation is that bugs in a program often
produces interesting visual effects, and that is motivating.
	</p>
	<p>
The current system needs some drastic make over.  One major factor is
to support simulations in 3D.  While the numeric computation itself is
all scalar values and agnostic to the dimensionality, the primitive
provided by the system and the concept of patches only works well for
2D.  New ideas are called for to manage the spatial data.
	</p>
	<p>
As future work, supporting more mathematics, such as vectors and
matriices is important.  While a first-time user may not use vectors
and matrices initially and write two lines of code for one vector
operation, ideally the language may ramp up the user to use those
powerful mathematical tools.
	</p>
</section>

<section>
	<h2 id="language">The Primer of the Shadama Language (The one pager) </h2>
	<p>
The Shadama language uses the turtles and patches abstraction, which
is drawn from the tradition of StartLogo.  Turtles are organized into
"breeds".  Each breed can declares its own variables.

        <h3 id="breeds">Breeds</h3>
  A breed is
declared in the program with the "breed" statement.  For example, a
statement:
<pre class="code">
breed MyTurtle (x, y)
</pre>
</p>
<p>
creates a breed of turtle called "MyTurtle", and specifies that each
turtle in the breed has two own properties called "x", and "y".
You can have as many breeds as you like, and as many own properties for
each as you like.
	</p>
	<p>
The type of own properties (and other variables in general) are
limited to scalar floats.
	</p>
	<p>
To define behavior for turtles, you define a method with the def
statement.  For example, you an define a method called "move" like
this:<br>
<pre class="code">
def move() {
  this.x = this.x + 1;
  this.y = this.y + 1;
}
</pre>
</p>
<p>
Intuitively, this says that when a method is invoked for a turtle, the
turtle's x value and y value are incremented by one.  The "this"
keyword followed by a period "." and the name of the own variable is
the syntax to access an own variable.
	</p>
	<p>
To invoke a method, it has to be done for all turtle in a breed at the
same time.  Only place you can do it is a static function.  For
example, a static function:<br>
<pre class="code">
static step() {
  MyTurtle.move();
}
</pre>
</p>
<p>
calls the move function on all turtles of the MyTurtle breed.  Besides
user-defined methods, there are "primitives" that provide a certain
pre-defined features. The following is a list of primitives for
breeds.
<ul>
<li> <code>aBreed.setCount(count);</code>
  <p>
  This sets the number of turtles in the breed.  If the number
  increases, the newly "created" turtles' own variables are
  initialized with 0.  In the current implementation, there is the
  limit on the number of turtles in a breed.  By default, it is about 1
  million.  (It is provided by the  square of a constant called TEXTURE_SIZE in the
  implementation.)

  For example, a static function:
<pre class="code">
static setup() {
  MyTurtle.setCount(10000);
}
</pre>
	</p>
	<p>
will set the number of turtles in the MyTurtle breed to 10,000.
	</p>
<li> <code>aBreed.fillRandom(name, min, max);</code>
	<p>
  For all turtles in the breed, this sets the own variable specified by
  the string to be a random (floating point) number between min
  (inclusive) and max (exclusive).  It does not change the number of
  turtles in the breed.  For example,
  <pre class="code">
static setup() {
  MyTurtle.setCount(10000);
  MyTurtle.fillRandom("x", 0, 100);
}
  </pre>
  </p>
  <p>
  will make each of the 10,000 instance's "x" own variable to be a
  random floating point number between 0 and 100. (That is, the
  results are not limited to integral values.)
 </p>
<li> <code>aBreed.fillRandomDir(dxName, dyName);</code>
	<p>
  This assumes a two-dimentional space, and for each turtle in the
  breed, generate a random 2D unit direction vector (that is, a vector
  pointing to a direction in a 2D space, and whose length is one) and
  store its x and y component of the vector into the own variables
  specified by dxName and dyName, respectively.  For example,
  <pre class="code">
static setup() {
  MyTurtle.setCount(10000);
  MyTurtle.fillRandomDir("dx", "dy");
}
</pre>
</p>
<p>
sets "dx" and "dy" of a turtle with a pair of values that are (dx * dx
+ dy * dy) = 1 (or close to that, within the limit of numerical
computation errors).
</p>
<li> <code>aBreed.fillSpace(xName, yName, xDim, yDim);</code>
	<p>
  This sets the number of turtles in the breed to be xDim * yDim.  Then, assuming they are in the two-dimentional space, it places the turtles at all 2D grid points within in the (0..xDim, 0..yDim) area.  For example,
<pre class="code">
static setup() {
  MyTurtle.fillSpace("x", "y", 100, 100);
}
</pre>
</p>
<p>
creates 10,000 turtles for the MyTurtle breed, and their "x" and "y" own variables becomes the integral grid points spanned by (0, 0) and (99, 99), inclusive.
</p>
<li> <code>aBreed.fillImage(xName, yName, rName, gName, bName, aName, anImageData);</code>
	<p>
  The anImageData argument is a Javascript ImageData object.  This
  sets the turtle count of the breed to be anImageData.width *
  anImageData.height.  Then as in fillSpace, it places those turtles
  at the 2D grid points within the image extent, and update their own
  variables specified by rName, gName, bName, and aName with the RGBA
  color component values of the image.  Note that while the color
  components in the ImageData ranges from 0 and 255 (integral values),
  the color value in Shadama is normalized to the 0.0 and 1.0 range
  (inclusive).  For example,
<pre class="code">
breed MyTurtle (x, y, r, g, b, a)
static setup() {
  MyTurtle.fillImage("x", "y", "r", "g", "b", "a", anImage);
}
</pre>
</p>
<p>
(where the value of anImage can be taken from the global variable
described below), will create the number of turtles equal to the pixel
count in anImage and store the anImage's color component values,
scaled to 1.0, into r, g, b and a own variables.
</ul>

<h3 id="breeds">Breeds</h3>
<p>
Besides breeds of turtles, you can create patch variables.  A patch
variable assumes a two dimentional space of the fixed size (by default
512x512, specified as FIELD_WIDTH and FIELD_HEIGHT), and a cell at
each integral coodinate in the space holds a set of own variables.
For example, a statement:
<pre class="code">
patch Field (nx, ny)
</pre>
</p>
<p>
declares a patch variable, and each cell in the patch variable holds
two values "nx" and "nyclas".
</p>

<p>
To manipulate patches, they are pssed into a method as arguments.  An
argument for a method can be either a scalar value or a patch variable.
</p>
<p>
The caller of a method is always a static function.  To pass in a patch variable
to a method, you pass the name of the patch variable as an argument.
On the callee, which is executed in the context of a turtle, the
nearest patch cell will be bound to the argument.  For example, this code:
</pre class="code">
breed MyTurtle (x, y, r, g, b, a)
patch Field (r, g, b, a)

def store(field) {
  field.r = this.r;
}

static setup() {
  MyTurtle.fillImage("x", "y", "r", "g", "b", "a", anImage);
  MyTurtle.store(Field);
}
</pre>
</p>
<p>
declares a breed called MyTurtle, and a patch variable called Field.
The "setup" function calls the "store" method with "Field" as an
argument.  The store method, executed for each turtle in Turtle,
store the turtle's r own variable into the nearest cell in the patch.
</p>

<p>
The opposite direction of data transfer is also possible.  For example,
<pre class="code">
def load(field) {
   this.r = field.r;
}
</pre>
</p>
<p>
each turtle reads the r own variable in the patch cell at where the
turtle is and store it into its own variable.
</p>
<p>
You can pass in multiple patches to a method.  For example,
<pre class="code">
patch Field1 (nx, ny, r, g, b, a)
patch Field2 (nx, ny, r, g, b, a)
def transfer(f1, f2) {
  f2.r = f1.r;
  f2.a = f1.a;
}
</pre>
</p>
<p>
and even
<pre class="code">
def swap(f1, f2) {
  f2.r = f1.r;
  f1.r = f2.r
}
</pre>
</p>
<p>
are valid.
</p>

<h3 id="variables">Local and Global Variables</h3>
<p>
A method can have a local variable declared by a "var"
statement.  The scope of the variable is the whole method,
regardless where it is declared.  There can be at most one "var"
declaration for the saem variable name, unlike JavaScript.
</p>
<p>
Static functions have global variables, which are shared
by all static functions and persisted across the invocations of static
functions.  For example, if you have two static functions:
<pre class="code">
static setup() {
  var begin = 1;
}

static loop() {
  if (begin) {
    begin = 0;
  }
}
</pre>
</p>
<p>
The begin variable is unique and can be referred to from
both setup and loop.
</p>

<p>
There are built in global variables.
</p>
<ul>
<li> <code>mousemove</code>: an object which has property x and y
<li> <code>mouseup</code>:  an object which has property x and y
<li> <code>mousedown</code>: an object which has property x and y
<li> <code>time</code>:       a floating point value in seconds since the last time a specially named metho setup is called.
<li> <code> width, height</code>: the width and height of the visible 2D space.
<li> <code>Display</code>:           a stand in to be a left of the dot notation
</ul>

<h3 id="parallelism">Parallelism</h3>
<p>
When there are many turtles and they are writing into a patch
variable, it is possible that more than one turtles are at the same
cell and try to write into the same cell.  The result is non-deterministic.
</p>
<p>
Also, you cannot read a value that you "just" wrote within the same
method.  For example, if you have a function that looks like:
<pre class="code">
def test() {
  if (this.r > 0) {
     this.r = 0;
  } else {
     this.r = 1; 
  }
  this.b = this.r;
}
</pre>
</p>
<p>
the r own property and b own variable will not have the same value
even though the last line reads "this.b = this.r;".  The assignments into this.r in the if statement flips the value, but the actual update of the own property
does not take effect until the function finishes.  For instance, the value read
by the last "this.r" is still the old value.
</p>
<p>
If you want it so that this.b and this.r will always have the same value, you
can use a local variable and write the above code as:

<pre class="code">
def test() {
  var r = this.r;
  if (r > 0) {
     r = 0;
  } else {
     r = 1; 
  }
  this.r = r;
  this.b = r;
}
</pre>

</p>

<h3 id="control-structure">Control structure</h3>
<p>
Only control structure supported is the if statement.  As GLSL 3.0 supports variable-count loops, Shadama should be able to support loops; but it has not implemented.
</p>
<p>

<h3 id="function-primitives">Function Primitives</h3>
<p>
There are number of functions available from
methods.  Most of them actually result in a direct call
to the GLSL built-in functions.  For example, 

<pre class="code">
def prims(x) {
  var c = cos(x);
  var s = step(0.5, x);
  var a = abs(x);
  var f = fract(x); // the fraction part of x
  
  this.r = c * s * a * f;
}
</pre>
</p>
<p>
computes a value successfuly (though an arbitrary value) and stores it into the r variable.
</p>

<h3 id="otherlimitations">Other Limitations</h3>
<p>
There are some limitations, and some of which are even idyosynchratic.
One limitation is that one method can take patch variables or scalar
values but not other turtles.  For example, you cannot execute the
following code:

<pre class="code">
breed A (x, y)
breed B (x, y)

def hit(other) {
  var diff = other.x - this.x;
  ...
}

static step() {
  A.hit(B);
}
</pre>
</p>
<p>
because the "step" static function calls "hit" with a breed as
argument.  It is not a sensible program, anyway: which instance of B
should be bound to "other"?
</p>
<p>
Another limitation is that you cannot write into an own variable of
this *and* a patch's own from the same method.  For example, the
following is invalid:
<pre class="code">
def test(field) {
  field.r = 1;
  this.r = 1;
}
</pre>
</p>
<p>
This imitation is derived from the implementation consideration on
current WebGL features and may be lifted in the future.  Also, by
doing more code analysis, it may be made possible to aleviate the
limitation.  But for the time being, you need to split this kind of
function into two, each only write into either patches' own variables,
or own variables of "this".
</p>

<h3 id="other-notes">Other Notes</h3>
<p> 
Methods are not bound to a breed.  The "set" method below:
<pre class="code">
breed A (x, r)
breed B (x, y, r, g)
breed C (r)

def set() {
  this.r = 1;
  this.x = 0;
}

static test() {
  A.set();
  B.set();
}
</pre>
</p>
<p>
can be called both for breed A and breed B, but not breed C, because
its only requirement is that the breed has own variables called "r"
and "x", which are referred to from the function.
</p>
</section>

      <section>
        <h2>References</h2>
      </section>

    </article>
  </body>
</html>
