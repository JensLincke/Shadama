<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Shadama: A Particle Simulation Programming Environment for Everyone</title>
    <link rel="stylesheet" href="tufte.css"/>
    <link rel="stylesheet" href="latex.css"/>
    <link rel="stylesheet" href="style.css"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <script>
var shadamaEvents = [
    [`Our first example of Shadama is a simple physics simulation of particles and gravity.`, 0], 
    [`As in the LOGO programming language, we refer to mobile objects as turtles. Here, we 
      declare a breed of turtle such that each turtle will have properties
      "x", "y", "r", "g", "b" and "a".`, 5],
    [`A method is defined with the keyword "def". Methods are executed on
each turtle in a breed. Here, we've defined the "setColor" method to use the turtle's x and y
coordinates to assign them a red and green value.`, 15],
    [`In the static function "setup", we set the number of
turtles in the breed to be 3,000 and then set all turtle's x and y coordinates to be a
random number between 0 and 512. We run "setup" by hitting Cmd-S.`, 27],
    [`Those dots may be hard to see, but we can increase the number of turtles
to 30,000, 300,000 or 1 million.`, 38],
    [`What we want to do next is to move those turtles around. So we define
a method called "move". Move increments the x and y of the turtles. We call
the move method from a static function "step".`, 50],
    [`When we click the "step" clock, "step" is repeatedly executed and the turtles move.`, 61],
    [`Interestingly, while they are moving, we can edit the program on the
fly and the changes take effect as soon as we hit Cmd-S. We can add an
argument to "move", use it in the code, change the call site and the
turtles that went off screen come back.`, 66],
    [`We could even allow each individual turtle to have its own
velocity. So let's add properties "dx" and "dy" to each turtle. Then, we use them in
"move". Here, instead of "n", we increment the "x" and "y" of each turtle
according to their "dx" and "dy".`, 90],
    [`We call the primitive "fillRandom" to set the "dx" and "dy" to be the x and y components
of a randomly-chosen direction vector. Now, all turtles move
in their own individual directions.`, 107],
    [`Let's run it again by executing "setup" manually.`, 120],
    [`Now we'll change this to be a simple gravity simulation. To do so, we add constant
acceleration to the "y" component of the velocity.  Now all turtles are
accelerating toward the bottom.`, 125],
    [`We don't want those particles to go out of bounds. So we modify
the "move" method. First we store "dx" and "dy", as well as the possible
new location of "x" and "y" into local variables.`, 135],
    [`When "newX" is out of bounds, we make the turtle bounce back.`, 145],
    [`When "newY" is out of bounds below, we wrap the value around to the top.`, 152],
    [`After adjusting those variables,
we write the values back to the turtle's properties. Now one million
turtles are falling down, bouncing off the side walls, and wrapping around
to the top.`, 160],
    [`We are now going to create a simulation with large objects. To do so, we use what's called a "patch". A
patch is a 2D grid of cells where turtles can store values. Here,
we create a patch called "Field", and add "r", "g", "b", and "a" properties for each cell.`, 176],
    [`And, we define a breed called "Filler" that operates on the Field.`, 197],
    [`Now we define a method called "fill". The argument for this method is the patch, and
turtles executing this method update the patch cell value at their x and y coordinates.`, 203],
    [`We modify "setup" to use a primitive called
"fillSpace", which creates turtles of the Filler breed and
places them at all integral grid points. When this "setup" is called,
and the "fill" method is called, each "r" and "g" of the patch get values derived from its position, resulting 
in this color gradient.`, 214],
    [`Let's make some shapes now. We define
the "fillCircle" method to replace "fill". Let's also add the "clear" method, which clears the field's values.`, 231],
    [`"fillCircle" works by having each Filler turtle
check whether it is within the radius of the circle. If it is, it writes
the value into their corresponding cell.`, 244],
    [`In the "setup" function, we call "fillCircle" and get a circle at (100, 100).`, 264],
    [`Shadama programs can also be interactive. Let's split the "setup" function and
create another one called "loop".`, 273],
    [`Notice to the right that there is a variable
called "mousemove", which changes its value as we move the mouse pointer in the
display. That is an indication that we can use the value in our
program.`, 288],
    [`Now let's tie it all together. This code has methods we used
previously, such as "setColor". "fillCircle" is slightly modified so that
it sets normal vectors for the circle in the patch.`, 308],
    [`In the "move"
method, each turtle checks the normal in the patch cell where the turtle is
located and computes a new direction from the dot product with the normal. When we run
this, particles bounce off the circle and make a beautiful pattern.`, 320],
    [`However, it is a bit hard to see because the colors of the turtles are too
similar. Here, we change the "setColor" method so that instead of using "x"
and "y" position, we use the velocity "dx" and "dy" to determine the turtles'
color.`, 348],
    [`Then we call "setColor" from "loop", so that the colors are updated continuously.`, 360],
    [`Here, horizontal velocity corresponds with reddish color, and vertical
velocity corresponds with greenish color. The visualization can be quickly adjusted
to match how you prefer to view the simulation.`, 365], 
    [`For fun, you can make two circles that move symmetrically.`, 375],
    [`Here's an interesting variation of our program. Instead of modeling gravity as pulling downward, gravity follows
the inverse square law in relation to the mouse pointer location. It looks like
there are large structures, but it's actually just a
quarter million particles from regular initial positions, all following the inverse square law.`, 384],
    [`Shadama allows the user to import images. The built-in "fillImage"
takes an image object, creates enough turtles to cover it, and sets the turtle colors
based on the image's pixel values. This looks like an image but it is
actually a bunch of turtles.`, 422],
    [`We reuse our previous "move" method, set the
direction vectors randomly, create the "loop" method that calls "move", and run "loop".`, 442],
    [`For fun,
We can use the turtles' red and green values to determine turtle velocity, causing an
an interesting effect.`, 466],
    [`Let's use those pixels in our gravity simulation.`, 488],
    [`The code checks the timer, and every 10 seconds, it gathers all turtles to their original position.`, 500],
    [`We can also try some mathematical functions. This is a program to
visualize the Mandelbrot set. Notice how we can change the color scheme on the
fly.`, 511],
    [`This is Conway's Game of Life.`, 532],
    [`Again, we can change the program while
the simulation is running, and the code change is reflected in the
simulation right away, without needing to restart.`, 537]];
    </script>
    <script>
       var eventDivs; // [[div, time]]

       var transcript;
       var interval;
       var caption;

       function processOne(event) {
	   var p = document.createElement("div");
	   p.innerHTML = "<p class='caption'>" + event[0] + "</p>";
           caption.appendChild(p);
	   return [p, event[1]];
       }

       /* YouTube Javascript API stuff */
       var tag = document.createElement('script');
       tag.src = 'https://www.youtube.com/iframe_api';
       var firstScriptTag = document.getElementsByTagName('script')[0];
       firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
       var player;
       function onYouTubeIframeAPIReady() {
	   player = new YT.Player('player', {
	       height: '576',
	       width:  '1024',
	       videoId: 'kHTIv7HUPt8',
	       events: { 'onStateChange': onPlayerStateChange },
	       playerVars: {rel: 0, showinfo: 0},
	   });
       }
       function onPlayerStateChange(e) {
	   if (e.data == YT.PlayerState.PLAYING) {
	       interval = window.setInterval(updateEventHighlight, 500); // update every half-second
	       updateEventHighlight();
	   }
	   if (e.data == YT.PlayerState.ENDED  ||
               e.data == YT.PlayerState.PAUSED ||
               e.data == YT.PlayerState.BUFFERING) {
	       window.clearInterval(interval);
	   }
       }

       function findEvent(time, events) {
         for (var i = 0; i < events.length - 1; i++) {
	     var pair = events[i];
	     var next = events[i+1];
             if (pair[1] <= time && time < next[1]) {
		 return pair[0];
	     }
	 }
	 var pair = events[events.length -1 ];
         if (pair[1] < time) {
	     return pair[0];
	 }
       }

       function updateEventHighlight() {
	   Array.from(document.getElementsByClassName('highlight')).forEach(function (p) {
	       p.classList.remove('highlight');
	   });
	   var time = parseFloat(player.getCurrentTime());
	   var event = findEvent(time, eventDivs);
	   if (!event) {
	       return;
	   }
	   caption.scrollTop = event.offsetTop - eventDivs[0][0].offsetTop;
	   event.firstChild.classList.add("highlight");
       }

       function initialize() {
	   caption = document.getElementById("caption");
	   eventDivs = shadamaEvents.map(processOne); // [[div, time]]  As a side-effect it adds divs to caption
       }
       onload = initialize;
  </script>
  </head>
  <body>
    <article>
      <h1 id="title">Shadama: A Particle Simulation<br> Programming Environment for Everyone</h1>
      <p class="subtitle">Yoshiki Ohshima, Dan Amelang and Bert Freudenberg<br>
      HARC/Y Combinator Research</p>

      <section id="abstract">
        <p>
We present a prototype of a programming system called Shadama, which
is designed to help writing programs that creates large number of
objects, control them and visualize them.  Shadama's basic execution
model follows the tradition of StarLogo and its "turtles and patches"
abstraction.
<label for="sn-starlogo"
       class="margin-toggle sidenote-number">
</label>
<input type="checkbox"
       id="sn-starlogo"
       class="margin-toggle"/>
<span class="sidenote">
 M. Resnick, Turtles, Termites, and Traffic Jams: Explorations
in Massively Parallel Microworlds (Complex
Adaptive Systems). MIT Press, 1994.<br>
<img src="starlogo-book.jpg" width="50%" height="50%" style="margin-left: 20.2%"/>
</span>
&nbsp; The abstraction is proven to be effective and easy to
use.  The primary audience intended of the language is high-school
level students to make physics simulations.
	</p>
        <p>
The environment supports <i>liveness</i>.  When the user saves the
program, the code change immediately takes effects on the running
simulation without needing to restart the simulation.
	</p>
        <p>
The user code is translated to the Open GL Shading Language.
<label for="sn-glsl"
       class="margin-toggle sidenote-number">
</label>
<input type="checkbox"
       id="sn-glsl"
       class="margin-toggle"/>
<span class="sidenote">
OpenGL Shading Language (<a href="https://khronos.org/registry/OpenGL/">OpenGL Registry</a>)
</span> &nbsp;
The runtime data of the program is stored and kept in the memory of
graphics card for fast execution.
	</p>
        <p>
A prototype of Shadama can be found <a href="http://tinlizzie.org/~ohshima/shadama2">here</a>.
Be aware that Shadama requires WebGL 2 and is affected by the floating point precision provided
by your graphics card. Thus, it only works on certain computer systems.
From our experience, it seems to work better on computers with an AMD Radeon graphics
card and on Chrome or Firefox browsers.
</p>
      </section>
      <section>
        <h2>Introduction</h2>
        <p>
The computing power available to us today is astounding.  Achieving
one teraflop of performance was a milestone for a building-sized supercomputer in
the late '90s, but now we expect smart phones to reach this same milestone soon.
Computing performance will only continue to increase in the future.
	</p>
	<p>
But what are people using this power for?  Not to be critical
of our friends and family, but people are generally more
interested in watching cat videos and playing games than trying to
invent self-flying personal airplanes or discover the graviton.

All joking aside, one of the big problems we face today is our
struggle to advance science literacy, even within a
technologically-advanced society.  We need the next
generation to embrace science more, not less.
	</p>
	<p>
We think now is a good time to redouble our efforts to provide an
environment where students, artists, and even professional
programmers can tap into the computing power that is available.
	</p>
	<p>
To this end, we have been working on a prototype of a
programming language intended for high school students to explore
scientific ideas.
	</p>
	<p>
  Science is about making the invisible visible.  One notable example
of an invisible yet important concept is molecules in a gas.  We would
like students to learn about this, not by rote memorization, but
through actual experiments and model-building.  With the help of
computers, students can make a dynamic model and understand it more
deeply.  This kind of environment will help students construct
knowledge by doing, in line with the constructivism philosophy of
education.
	</p>
	<p>
<b>This is the motivation behind our prototype of a programming environment
to create simulations.</b>
	</p>
	<p>
We set ourselves out to make a prototype of the language, that aims
to satisfy following goals:
<ul>
<li> Object-Oriented</li>
<li> Large number of objects</li>
<li> Liveness</li>
</ul>
       <p>
As the basis for our prototype, we follow the tradition of StarLogo,
where objects are organized into turtles and patches.  For those students
who have used Scratch, specifying the behavior by code for one object is
already familiar.  Also, using the "color-touching"
block to sense the value around a sprite probably is familiar, too.  
Breeds and patches are straightforward extensions from those concepts,
and we expect that most students can pick them up easily.
       </p>
       <p>
For the second point, there is a trade-off between having easy
language semantics and providing high performance.  On one hand, we
would like an end-user language to be free from constraints imposed by
the particular nature of hardware.  On the other hand, however, there
are some fundamental limitations in the execution model of today's
graphics hardware.  In particular, sharing turtles' own states
directly with others, or dynamically constructing a list of turtles in
its neighborhood, are not implementable.  But we found that the
indirect communication scheme facilitated by patches mitigates the
limitation.
       </p>
       <p>
For the third point, the environment should show the effects of user
actions, in this case code changes, as soon as possible.  However,
when the user already has a running real-time simulation, we would not
want to restart the simulation for each and every key stroke.  We
think that the user rather want to batch code changes to a
<i>chunk of meaningful code change</i> before the system adapts to it.
</p>
<p>
An example of a meaningful chunk is to change the arity of a function:
it is not sensible to run the program until both the function
definition and its caller have been changed.  After changing those
different places in the code, the user can make a minimum gesture
(such as hitting Cmd-S for save), and the change can take effects
immediately.
       </p>
</section>
<section>
	<h2 id="a-science-experiment">A Science Experiment</h2>
<iframe width="640" height="360" src="https://www.youtube.com/embed/07D0nB3mgLA" frameborder="0" allowfullscreen></iframe>
	<p>
We begin with an actual science experiment.
This movie shows a vacuum cannon.  The cannon is a six foot PVC
pipe connected to a vacuum pump.  We put a ping pong ball inside the pipe,
cover the ends with sturdy but breakable material (such as plastic plates),
and pump the air out.
	</p>
	<p>
The pump reduces the pressure inside the tube to about 20% of full atmospheric pressure.
	</p>
	<p>
When the end near the ping pong ball is broken open by a box cutter, the
air molecules that rush into the pipe move into the
low pressure space and the ping pong ball is pushed out the other end.
Our crude setup can accelerate the ball to a speed of over 200 meters per second
(about 60% of the speed of sound).  Others have built similar setups
that can achieve supersonic speed.
	</p>
        <p>
An interesting point to understand is that it is just movement of
molecules that is is causing the ball to shoot out; it is not that the
vacuum is sucking molecules into the pipe.
</p>
<p>
The invisible molecules that cause the ball to shoot out can
be made &ldquo;visible&rdquo; in a sense not only through this physical experiment,
but also through a computer simulation that reproduces the same phenomenon.
Creating such simulations is the purpose of our programming environment.
	  </p>
</section>
<section>
	<h2 id="shadama-in-Action">Shadama in Action</h2>
	<p>
The following movie shows some examples done in our prototype programming environment called Shadama.

The script below provides an explaination of the movie.  You can pause the movie at any time to scroll through and read the explanation.  The captions work better when the movie is not in full screen.
	</p>
<!--<iframe width="1024" height="576" src="https://www.youtube.com/embed/g4rloq5FRLM" frameborder="0" allowfullscreen></iframe>-->
  <div id="video">
    <div id="player"></div>
  </div>
  <div id="caption" class="caption"></div>
  <hr>
</section>
<section>
	<h2 id="implementation">Implementation</h2>
</section>
<p>
Shadama is a web-based technology.  It uses WebGL 2.0 and the OpenGL
Shading Language version 3.0.  A property for all turtles in a breed
is stored in one texture.  The type texture type is "R32F" to treat
them as a vector of scalar values.  The multiple render target feature
is used to write back the changes to multiple properties at once.
</p>
<p>
From the user code, the vertex shader code and fragment shader code,
along with some support code in JavaScript are generated.  The
translator is written in Ohm.
<label for="sn-ohm"
       class="margin-toggle sidenote-number">
</label>
<input type="checkbox"
       id="sn-ohm"
       class="margin-toggle"/>
<span class="sidenote">
Ohm: A library and language for building parsers, interpreters, compilers, etc.
</span>
</p>

<section>
	<h2 id="related-work">Related Work</h2>
	<p>
One of the authors implemented a particle system as an extension of Etoys in the past.
<label for="sn-kedama"
       class="margin-toggle sidenote-number">
</label>
<input type="checkbox"
       id="sn-kedama"
       class="margin-toggle"/>
<span class="sidenote">
Kedama: A GUI-Based Interactive Massively Parallel Particle Programming System.<br>
<img src="kedama.png" width="50%" height="50%" style="margin-left: 20%" alt="Kedama screenshot" /><br>
</span> &nbsp;    Shadama can be seen as another attempt to bring the idea a new life.  Shadama's target audience is older than Kedama's.
	</p>
	<p>
The biggest inspiration for Shadama (and Kedama) was Resnick's
StarLogo.  The basic organization of Shadama objects is largely drawn
upon StarLogo's.  In fact, Shadama is missing some features
compared to StarLogo, as described in introdcution.
	</p>
	<p>
Swift et al. created a live programming environment for physics based
on Extempore.
<label for="sn-extempore-pic"
       class="margin-toggle sidenote-number">
</label>
<input type="checkbox"
       id="sn-extempore-pic"
       class="margin-toggle"/>
<span class="sidenote">
Live Programming in Scientific Simulation
<img src="extempore-pic.png" width="50%" height="50%" style="margin-left: 20%" alt="Extempore PIC demo screenshot" /><br>
</span> &nbsp;
This environment provides a flexible and dynamic
code swap and interactive data inspection to a sophisticated and optimized physics simulation
framework (called Particle-In-Cell).  The split of this environment is much in line with
our work, except that their work uses a third party engine as a black
box.  We believe that such an engine should be also accessible to the
leaners.
	</p>
	<p>
Lately, there are various simulation environments, such as Liquid Fun.
<label for="sn-liquidfun"
       class="margin-toggle sidenote-number">
</label>
<input type="checkbox"
       id="sn-liquidfun"
       class="margin-toggle"/>
<span class="sidenote">
LiquidFun.<br>
<img src="liquidfun.png" width="50%" height="50%" style="margin-left: 20%" alt="LiquidFun screenshot" />
</span>
&nbsp;  But the language for Liquid Fun is not designed for end-users.
</p>
<p>
Providing bindings to GLSL to high-level languages is a hot topic.
<label for="sn-ikra"
       class="margin-toggle sidenote-number">
</label>
<input type="checkbox"
       id="sn-ikra"
       class="margin-toggle"/>
<span class="sidenote">
Object Support in an Array-based GPGPU Extension for Ruby (ARRAY’16)
</span>.  &nbsp; Nicky Case has a simulation
construction environment based on emoji
<label for="sn-emoji"
       class="margin-toggle sidenote-number">
</label>
<input type="checkbox"
       id="sn-emoji"
       class="margin-toggle"/>
<span class="sidenote">
Simulation in Emoji<br>
  <img src="emoji.png" width="50%" height="50%" style="margin-left: 20%" alt="Simulation in Emoji screenshot" />
</span> &nbsp;  They use more sophisticated compilation techniques and use CUDA to fully utilize the power of GPU, yet again, the blance is toward the performance and power, rather than ease of use.  The authors think that Shadama can occupy a unique position at striking a good blance betewen the performance and ease of use.
	</p>
	<p>
There are blocks laungages for massively parallel particles, such as StarLogo Nova.
Currently, Shadama uses a textual language, based on the observation
that physics simulations often only takes concise problem description
so coding part is not the major obstacle.  But we are not ruling out
the other possiblities of syntax, or even visual representation of
program.
	</p>
</section>
<section>
	<h2 id="conclusions-and-future-work">Conclusions and Future Work</h2>
	<p>
This is an early prototype of the concept of a simulation language in
which users can make simulations, interactive art and various
visualization.  The liveliness of the environment encourages the
exploratory style of programming, that is handy to try different ideas
quickly.  An anecdotal observation is that a bug in a program often
produces interesting visual effects, and that is motivating.
	</p>
	<p>
We are thinking about various improvements to the system.  One major
addition is to fully support simulations in 3D.
While the numeric computation itself only uses scalar values and is agnostic to dimensionality, the primitives and concepts the system provides only work well for 2D applications. We will need new ideas to manage spatial data.
	</p>
	<p>
We plan to support more mathematics, such as vectors and matrices is in
our plans. While a first-time user may not use matrices and vectors
initially, we would eventually like them to learn these powerful concepts. 
Ideally the language will gradually introduce the user to these powerful mathematical tools.
	</p>
	<p>
We would like to conclude this report by stressing the importance of
education.  Education raises the awareness, and allow people to see
things with different light.  By seeing things differently, they will
find more problems but those problems are solvable if they know more
ways to attack.  And Science is one of the biggest asset humanhas has.  We hope that ideas like Shadama will help future education.
	</p>
</section>

      <section>
        <h2>References</h2>
	<ol type="1">
	  <li>
M. Resnick, Turtles, Termites, and Traffic Jams: Explorations
in Massively Parallel Microworlds (Complex
Adaptive Systems). MIT Press, 1994.
          </li>
	  <li>OpenGL Shading Language (<a href="https://khronos.org/registry/OpenGL/">OpenGL Registry</a>)</li>
          <li>Ohm: A library and language for building parsers, interpreters, compilers, etc. (<a href="https://ohmlang.github.io/">project page</a>)
	    <li>Kedama: A GUI-Based Interactive Massively Parallel Particle Programming System: Yoshiki Ohshima.  VL/HCC 2005, pp 91-98.</li>
          <li>Live Programming in Scientific Simulation: Ben Swift, Andrew Sorensen, Henry Gardner, Peter Davis, Viktor K. Decyk, Supercomputing Frontiers and Innovations, p. 4-15, Mar. 2016. (<a href="http://superfri.org/superfri/article/view/72">Journal page</a>)</li>
	  <li>LiquidFun: (<a href="http://google.github.io/liquidfun/">the project page</a>)</li>
	  <li>Matthias Springer and Hidehiko Masuhara, Object Support in an Array-based GPGPU Extension for Ruby Proceedings of the 3rd ACM SIGPLAN International Workshop on Libraries, Languages, and Compilers for Array Programming (ARRAY’16), June 2016</li>
          <li>Simulation in Emoji: Nicky Case, (<a href="http://ncase.me/simulating/model/">project page</a>)</li>
        </ol>
      </section>
<section>
	<h2 id="language">Appendix: The Primer of the Shadama Language</h2>
	<p>
The Shadama language uses the turtles and patches abstraction, which
is drawn from the tradition of StarLogo.  A method is defined with the
"def" statement, and invoked on each turtle in a breed when invoked.
A static function invokes a method.

        <h3 id="breeds">Breeds</h3>
<p>
Turtles are organized into
"breeds".  Each breed can declare its own set of properties.
A breed is declared in the program with the "breed" statement.  For example, a
statement:
</p>
<pre class="code">
breed MyTurtle (x, y)
</pre>
</p>
<p>
creates a breed of turtle called "MyTurtle", and declares that each
turtle in the breed has two own properties called "x", and "y".
	</p>
	<p>
The type of properties are limited to scalar floats.
	</p>
	<p>
To define behavior for turtles, you define a method with the def
statement.  Here is an example:<br>
<pre class="code">
def move() {
  this.x = this.x + 1;
  this.y = this.y + 1;
}
</pre>
</p>
<p>
Intuitively, when this method is invoked on a turtle, the
turtle's x property and y property are incremented by one.
	</p>
	<p>
A method is invoked from a static function.  In a static function, The
breed name is used to specify which group of turtles to execute the
method, and all turtles in the receiving breed executes it
concurrently.  For example, a static function:<br>
<pre class="code">
static step() {
  MyTurtle.move();
}
</pre>
</p>
<p>
calls the move method on all turtles of the MyTurtle breed.  Besides
user-defined methods, there are "primitives" that provide certain
pre-defined features. The following is the list of primitives for
breeds.
<ul>
<li> <code>aBreed.setCount(count);</code>
  <p>
  This sets the number of turtles in the breed.

  For example, a static function:
<pre class="code">
static setup() {
  MyTurtle.setCount(10000);
}
</pre>
	</p>
	<p>
will set the number of turtles in the MyTurtle breed to 10,000.
</p>
<p>
In the current implementation, there is a limit on the number of
turtles in a breed.  The limit by default is 1024 * 1024, or about 1 million.
	</p>
        </li>
<li> <code>aBreed.fillRandom(name, min, max);</code>
	<p>
  The fillRandom primitive sets the property specified by
  the string to be a random number between min
  (inclusive) and max (exclusive).  It does not change the number of
  turtles in the breed.  For example,
  <pre class="code">
static setup() {
  MyTurtle.setCount(10000);
  MyTurtle.fillRandom("x", 0, 100);
}
  </pre>
  </p>
  <p>
  will make each of the 10,000 instance's "x" property to be a
  random floating point number between 0 and 100.
 </p>
</li>
<li> <code>aBreed.fillRandomDir(dxName, dyName);</code>
	<p>

  The fillRandomDir primitive generates a random 2D unit direction
  vector (that is, a vector pointing to a direction in a 2D space, and
  whose length is one) and store its x and y component of the vector
  into the own property specified by dxName and dyName, respectively.
  For example,
  <pre class="code">
static setup() {
  MyTurtle.setCount(10000);
  MyTurtle.fillRandomDir("dx", "dy");
}
</pre>
</p>
<p>
sets "dx" and "dy" of a turtle with the x- and y- component of a random unit vector.
</p>
</li>
<li> <code>aBreed.fillSpace(xName, yName, xDim, yDim);</code>
	<p>
The fillSpace primitive first sets the number of turtles in the breed
to be xDim * yDim.  Then, it places the turtles at all 2D grid points
within the (0..xDim, 0..yDim) area.  For example,
<pre class="code">
static setup() {
  MyTurtle.fillSpace("x", "y", 100, 100);
}
</pre>
</p>
<p>
creates 10,000 turtles of the MyTurtle breed, and their "x" and "y" properties become the integral grid points spanned in (0, 0) and (99, 99) (inclusive).
</p>
</li>
<li> <code>aBreed.fillImage(xName, yName, rName, gName, bName, aName, anImageData);</code>
	<p>
  The anImageData argument is a Javascript ImageData object.  This
  sets the turtle count of the breed to be anImageData.width *
  anImageData.height.  Then, similar to fillSpace, it places those turtles
  at the 2D grid points within the image extent, and update their own
  variables specified by rName, gName, bName, and aName with the RGBA
  color component values of the image.  Note that while the color
  components in the ImageData ranges from 0 and 255 (integral values),
  the color value in Shadama is normalized to the 0.0 and 1.0 range
  (inclusive).  For example,
<pre class="code">
breed MyTurtle (x, y, r, g, b, a)
static setup() {
  MyTurtle.fillImage("x", "y", "r", "g", "b", "a", anImage);
}
</pre>
</p>
<p>
(where the value of anImage can be taken from the global variable
called anImage.  Different kinds of variables are described below),
creates the same number of turtles to the pixel count of anImage, and
stores the anImage's color component values, scaled to 1.0, into r, g,
b and a properties.
</ul>

<h3 id="breeds">Patches</h3>
<p>
Besides breeds of turtles, you can create patches.  A patch
is a set of "cells" that can hold values.  A patch
assumes a two-dimentional space of the fixed size (by default
512 * 512).
For example, a statement:
<pre class="code">
patch Field (nx, ny)
</pre>
</p>
<p>
declares a patch, and each cell in the patch variable holds
two values "nx" and "ny".
</p>

<p>
To manipulate a patch, you pass them to a method as arguments.
</p>
<p>
The caller of a method is always a static function.  To pass in a
patch to a method, you pass the name of the patch as an argument.
Each turtle that executes the method can only access the nearest patch
cell.  For example, this code:
<pre class="code">
breed MyTurtle (x, y, r, g, b, a)
patch Field (r, g, b, a)

def store(field) {
  field.r = this.r;
}

static setup() {
  MyTurtle.fillImage("x", "y", "r", "g", "b", "a", anImage);
  MyTurtle.store(Field);
}
</pre>
</p>
<p>
declares a breed called MyTurtle and a patch called Field.
The "setup" function calls the "store" method with "Field" as an
argument.  The store method, executed for each turtle in Turtle,
store the turtle's r property into the r property of the nearest cell in Field.
</p>
<p>
A turtle can read values out from the patch cell as well.  For example, when the following method is executed:
<pre class="code">
def load(field) {
   this.r = field.r;
}
</pre>
</p>
<p>
each turtle reads the r property of the nearest patch cell and stores it into its property.
</p>
<p>
You can pass in multiple patches to a method.  For example,
<pre class="code">
patch Field1 (nx, ny, r, g, b, a)
patch Field2 (nx, ny, r, g, b, a)
def transfer(f1, f2) {
  f2.r = f1.r;
  f2.a = f1.a;
}
</pre>
</p>
<p>
and even
<pre class="code">
def swap(f1, f2) {
  f2.r = f1.r;
  f1.r = f2.r
}
</pre>
</p>
<p>
are valid.  
</p>

<h3 id="variables">Local and Global Variables</h3>
<p>
A method can have local variables declared by the "var"
statement.  The scope of the variable is the whole method,
regardless where it is declared.  There can be at most one "var"
declaration for the saem variable name, unlike JavaScript.
</p>
<p>
Static functions can use global variables, which are visible to all static functions.
For example, if you have two static functions:
<pre class="code">
static setup() {
  var begin = 1;
}

static loop() {
  if (begin) {
    begin = 0;
  }
}
</pre>
</p>
<p>
the begin variable can be referred to from both setup and loop,
</p>

<p>
There are built in global variables.
</p>
<ul>
<li> <code>mousemove</code>: an object which has property x and y</li>
<li> <code>mouseup</code>:  an object which has property x and y</li>
<li> <code>mousedown</code>: an object which has property x and y</li>
<li> <code>time</code>:       a floating point value in seconds since the last time a specially named metho setup is called.</li>
<li> <code> width, height</code>: the width and height of the visible 2D space.</li>
<li> <code>Display</code>:           a stand in to be a left of the dot notation</li>
</ul>
<p>
Note that mouse events are JS objects but methods can still only takes scalar values.

<h3 id="parallelism">Parallelism</h3>
<p>
When turtles are writing into a patch, it is
possible that more than one turtles are at the same cell and try to
write into it.  The result from this is non-deterministic.
</p>
<p>
Also, you cannot read a value that you "just" wrote within the same
method.  For example, if you have a function that looks like:
<pre class="code">
def test() {
  if (this.r > 0) {
     this.r = 0;
  } else {
     this.r = 1; 
  }
  this.b = this.r;
}
</pre>
</p>
<p>
the r property and b property will not have the same value after the invocation,
even though the last line reads <code>this.b = this.r;</code>.  The assignments into this.r in the if statement negates the value, but the actual update of the variable
does not take effect until the function finishes.
</p>
<p>
If you want it so that this.b and this.r will always have the same value, you
can use a local variable and write the above code as:

<pre class="code">
def test() {
  var r = this.r;
  if (r > 0) {
     r = 0;
  } else {
     r = 1; 
  }
  this.r = r;
  this.b = r;
}
</pre>

</p>

<h3 id="control-structure">Control structure</h3>
<p>
Only control structure supported is the if statement.  As GLSL 3.0
supports variable-count loops, Shadama should be able to support
loops; but it has not implemented.
</p>
<p>

<h3 id="function-primitives">Function Primitives</h3>
<p>
There are number of functions available from
methods.  Most of them actually result in a direct call
to the GLSL built-in functions.  For example, 

<pre class="code">
def prims(x) {
  var c = cos(x);
  var s = step(0.5, x);
  var a = abs(x);
  var f = fract(x); // the fraction part of x
  
  this.r = c * s * a * f;
}
</pre>
</p>
<p>
computes a value successfuly (though an arbitrary value) and stores it into the r variable.
</p>

<h3 id="otherlimitations">Other Limitations</h3>
<p>
There are some limitations, and some of which are even idyosynchratic.
One limitation is that one method can take patch variables or scalar
values but not other turtles.  For example, you cannot execute the
following code:

<pre class="code">
breed A (x, y)
breed B (x, y)

def hit(other) {
  var diff = other.x - this.x;
  ...
}

static step() {
  A.hit(B);
}
</pre>
</p>
<p>
because the "step" static function calls "hit" with a breed as
argument.  It is not a sensible program, anyway: which instance of B
should be bound to "other"?
</p>
<p>
Another limitation is that you cannot write into an own variable of
this *and* a patch's own from the same method.  For example, the
following is invalid:
<pre class="code">
def test(field) {
  field.r = 1;
  this.r = 1;
}
</pre>
</p>
<p>
This imitation is derived from the implementation consideration on
current WebGL features and may be lifted in the future.  Also, by
doing more code analysis, it may be made possible to aleviate the
limitation.  But for the time being, you need to split this kind of
function into two, each only write into either patches' own variables,
or own variables of "this".
</p>

<h3 id="other-notes">Other Notes</h3>
<p> 
Methods are not bound to a breed.  The "set" method below:
<pre class="code">
breed A (x, r)
breed B (x, y, r, g)
breed C (r)

def set() {
  this.r = 1;
  this.x = 0;
}

static test() {
  A.set();
  B.set();
}
</pre>
</p>
<p>
can be called both for breed A and breed B, but not breed C, because
its only requirement is that the breed has own variables called "r"
and "x", which are referred to from the function.
</p>
</section>

    </article>
  </body>
</html>
