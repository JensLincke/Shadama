<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Shadama: A Particle Simulation Programming Environment</title>
    <link rel="stylesheet" href="tufte.css"/>
    <link rel="stylesheet" href="latex.css"/>
    <link rel="stylesheet" href="style.css"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>

  <body>
    <article>
      <h1 id="title">Shadama: A Particle Simulation Programming Environment</h1>
      <p class="subtitle">Yoshiki Ohshima, Dan Amelang and Bert Freudenberg<br>
      HARC/Y Combinator Research</p>

      <section id="abstract">
        <p>
We present a prototype of a programming system called Shadama, which
is designed to help writing programs that creates large number of
objects, control them and visualize them.  Shadama's basic execution
model follows the tradition of StarLogo and its "turtles and patches"
abstraction.  The abstraction is proven to be effective and easy to
use.  The primary audience intended of the language is high-school
level students to make physics simulations.
	</p>
        <p>
The environment supports <i>liveness</i>.  When the user saves the
program, the code change immediately takes effects on the running
simulation without needing to restart the simulation.
	</p>
        <p>
The user code is translated to the Open GL Shader Language.  The
runtime data of the program is stored and kept in the memory of
graphics card for fast execution.
	</p>
        <p>
The prototype is available
at: <A href="http://tinlizzie.org/~ohshima/shadama2">Shadama Prototype
Page</A>.  Note that the system is sensitive to the floating point
precision provided by the graphics card, and consequently it rather
chooses a platform it runs.  On a computer with AMD Radeon graphics
card, and Chrome or FireFox browsers seem to work better.
</p>
      </section>
      <section>
        <h2>Introduction</h2>
        <p>
The computing power that is available for us is astounding, if we look
back in the history of computing just for a few years.  Achieving the
Teraflops mark was a milestone for a building-sized supercomputer in
late '90's.  Now, a smart phone has equivalent performance.  The computing performance
will continue to increase in the future.
	</p>
	<p>
But what are people doing with it?  I don't want to say bad things
about my friends and families, but they are more interested in
watching cat videos and playing solitaire, rather than trying to
invent self-flying personal airplanes, or to discover the graviton.
Jokes aside, one of the big problems we face today is that the
importance of science literacy seems to be discounted in this
technologically advanced society, when we will need the next
generation to embrace science more, not less.
	</p>
	<p>
We think now is a good time to restart our efforts to provide an
environment where school students, artists, and even professional
programmers can tap into the power that is available for us.
	</p>
	<p>
Along this line of efforts, we have been working on a prototype of a
programming language intended for high school students to explore
scientific ideas.
	</p>
	<p>
Science is about making invisible things visible.  One notable example
of invisible yet hugely important is gas molecules.  We would like
students to learn about them: not only with rote memorization of
words, but also through actual experiments, and
through building models.  And if the model is executable on a
computer, they can make a dynamic model to understand it more deeply.
	</p>
	<p>
So we set ourselves out to make a prototype of the language, that aims
to satisfy following goals:
<ul>
<li> Object-Oriented
<li> Large number of objects
<li> Liveness. 
</ul>
       <p>
As the basis for our prototype, we follow the tradition of StarLogo,
where objects are organized into turtles patches.  For those students
who have used Scratch, specifying the behavior of one object is
already familiar. Breeds and patches are straightforward extensions
and we expect that most students can pick them up easily.
       </p>
       <p>
For the second point, there is a trade-off between having easy
language semantics and providing high performance.  On one hand, we
would like an end-user language to be free from constraints imposed by
the particular nature of hardware.  On the other hand, however, there
are some fundamental limitations in the execution model of today's
graphics hardware.  In particular, sharing turtles' own states
directly with others, or dynamically constructing a list of turtles in
its neighborhood, are not implementable.  But we found that the
indirect communication scheme facilitated by patches mitigates the
limitation.
       </p>
       <p>
For the third point, the environment should show the effects of user
actions, in this case code changes, as soon as possible.  However,
when the user already has a running real-time simulation, we would not
want to restart the simulation for each and every key stroke.  We
think that the user rather want to batch code changes to a
<i>chunk of meaningful code change</i> before the system adapts to it.
</p>
<p>
An example of a meaningful chunk is to change the arity of a function:
it is not sensible to run the program until both the function
definition and its caller have been changed.  After changing those
different places in the code, the user can make a minimum gesture
(such as hitting Cmd-S for save), and the change can take effects
immediately.
       </p>
</section>
<section>
	<h2 id="a-science-experiment">A Science Experiment</h2>
<iframe width="640" height="360" src="https://www.youtube.com/embed/07D0nB3mgLA" frameborder="0" allowfullscreen></iframe>
	  <p>
We begins with an actual science experiment to motivate the narrative.
The movie above shows a vacuum cannon, created by the authors.  The
vacuum cannon is made out of a six foot PVC pipe, with a
vacuum pump connected.  We put a ping pong ball in it, cover the ends with soft
and sturdy but breakable materials such as plastic cake plates, and
pump the air out.  In this movie the pressure inside was about 20% of
the atmospheric pressure, which is decent but not extreme.
	  </p>
	  <p>
When one end near the ping pong ball is broken by a box cutter, the
air molecules that are moving toward the opening keep moving into the
low pressure space.  (Note that they are not "sucked in"; they
just happen to be moving to that direction.)  Those molecules hit the
ping pong ball and simply push it out from the other end. Our
version can achieve over 200 meters/sec, which is about 60% of the
speed of sound.  Some people have built one that can achieve super
sonic speed.
	</p>
        <p>
Recall that the idea that science is about making invisible visible.
The important point to understand is that it is just movement of
molecules that is is causing the ball to shoot away.  With this in
mind we would like to have an environment where students can actually
do the experiment in the real world and then make a simulation of it.
	  </p>
</section>
<section>
	<h2 id="shadama-in-Action">Shadama in Action</h2>
<iframe width="1024" height="576" src="https://www.youtube.com/embed/g4rloq5FRLM" frameborder="0" allowfullscreen></iframe>
	<p>
The following text is the explanation of the movie.  We should be able to have the narrative going but if not, please have two screens, and view the movie in full screen and see the text below.
	</p>
	<p>
Here we try to make a simple physics simulation where many particles
are following some gravity law.
	</p>
	<p>
In a Shadama program, we declare and use breeds of turtles.  Here, the
breed called Turtle is created.  Each turtle in the breed has x, y, r,
g, b and a properties.
	</p>
	<p>
  A method is defined with the keyword "def".  A method is executed on
each turtle in a breed.  The setColor method uses the turtle's x and y
coordinate and assign them into r and g.
	</p>
	<p>
In a static function called "setup", we first set the number of
turtles in the breed to be 3,000, set all turtle's x and y to be a
random number between 0 and 512.  We run it by hitting Cmd-S to run
it.  Okay, we don't see the result until we call the setColor method
and call the draw primitive.  Good.
	</p>
	<p>
Those dots may be hard to see, but we can increase the number of turtles
to 30,000, 300,000 and 1 million.
	</p>
	<p>
What we want to do next is to move those turtles around.  So we define
a method called move.  Move increments the x and y of turtles.  I call
the move method from a static function step.  When I set the clock on
step and repeatedly execute it, the turtles move.
	</p>
	<p>
Interestingly, while they are moving, I can edit the program on the
fly and the changes takes effect as soon as I hit Cmd-S.  I can add an
argument to move, use it in the code, change the call site and the
turtles that went off screen comes back.
	</p>
	<p>
We would actually like each individual turtle to have its own
velocity, so we add dx and dy to each turtle.  And then, we use them in
move.  Here, instead of n, we increment x and y of each turtle with
their dx and dy.
	</p>
	<p>
We add a primitive to set the dx and dy to be the x and y components
of a random direction vector.  Now, all turtles move
to their own directions.  Try again by executing setup,
	</p>
	<p>
We can make this to be a simple gravity simulation.  We add constant
acceleration to the y component of the velocity.  Now all turtles are
accelerated toward the bottom.
	</p>
	<p>
We don't want those particles to go out of bounds.  So we extend
the move method.  First we store dx and dy, as well as the possible
new location of x and y into local variables.  when newX is going out
of bounds, we make the turtle bounce back.  When newY is going below,
we wrap the value around to the top.  After adjusting those variables,
we write those values back to turtle's properties.  Now one million
turtles are falling down, bouncing off the side walls, and wrap around
to the top.
	</p>
	<p>
We are going to add some large objects.  To do so, we use a patch.  A
patch is a set of 2D grid cells where turtles can store values.  Here,
we create a patch called Field, and a breed called Filler that
operates on it.
	</p>
	<p>
We define a method called fill.  This method takes an argument, and
updates fields, values.  And the setup uses a primitive called
fillSpace, which create enough number of turtles in the breed and
locate them at all integral grid point.  When this setup is called,
and the fill method is called for all turtles in the Filler breed the
r and g of the patch gets values based on its position and it results
in this gradation.
	</p>
	<p>
Instead of gradation, let us make some shapes.  So we define
the fillCircle method instead.  The idea of fillCircle is that each turtle
checks whether it is within the radius, and only when it is, it writes
values into the cell.  We define the clear method, and now we use them
in setup.  We get a circle at (100, 100).
	</p>
	<p>
We can make the program interactive.  Split the setup function and
create another one called loop.  Notice that there is a variable
called mousemove, which updates when you move the mouse pointer in the
display.  That is an indication that we can use the value in our
program.
	</p>
	<p>
Now let us tie all together.  This code has methods we used
previously, such as setColor.  FillCircle is slightly modified so that
it sets the normal vector for the circle in the patch.  In the move
method, each turtle checks the normal in the patch cell where the turtle is
on, computes the new direction that uses the dot product.  When I run
this, particles are bouncing off the circle as expected.
	</p>
	<p>
However, it is a bit hard to see because the colors of turtles are too
close.  Here, we change the setColor method so that instead of the x
and y position, we use the the velocity dx and dy to decides its
color.  Then we call setColor from loop, so that it updates its color
all the time.
	</p>
	<p>
Here, horizontal velocity is rendered as reddish color, and vertical
velocity is rendered as greenish color.  As you can see, you can
change the visualization quickly and observe the simulation in a way
you like.
	</p>
	<p>
For fun, you can make two circles that moves symmetrically.
	</p>
	<p>
This is a variation of this program.  I replace the code.  Here,
instead of modeling the gravity pulling downward, the gravity follow
the inverse square law from the mouse pointer's location.  It appears
that there is large structure, but the truth is that it is just
quarter million particles had a regular initial condition, and
following the inverse square law.
	</p>
	<p>
Shadama allows the user to import an image.  The primitive fillImage
takes an image object, and creates enough turtles and set their colors
based on the images pixel values.  This looks like an image but it
actually a set of turtles.  We define the same move method, set the
direction vector to random directions, an run the function.  For fun,
if you use the r and g channel values for the velocity, you can make
an interesting effect.
	</p>
	<p>
WE can try some mathematical functions.  This is a program to
visualize the mandelbrot set, We can change the color scheme on the
fly for example.
	</p>
	<p>
And, this is the Game of Life.  Again, we can change the program while
the simulation is running, and the code change is reflected to the
simulation right away, without needing to restart it.
	</p>
</section>
<section>
	<h2 id="implementation">Implementation</h2>
</section>
<p>
Shadama is a web-based technology.  It uses WebGL 2.0 and the shader
language version 3.0 provided by WebGL 2.0.  A turtle's own property
is stored in one texture, whose type is "R32F" and it is treated as a
vector of scalar values.  Also the multiple render target is used to
write back the changes to multiple properties at once.
</p>
<p>
From the user code, the vertex shader code and fragment shader code,
along with some support code in JavaScript are generated.  The
translator is written in Ohm[].
</p>

<section>
	<h2 id="related-work">Related Work</h2>
	<p>
The major inspiration for Shadama is Resnick's StarLogo.  The basic
organization of Shadama objects is largely drawn upon StarLogo, and in
fact Shadama is missing some key features to access other turtles from
a turtle.  One of the author did a particle extension called Kedama
for Etoys.  The name Shadama is an homage to Kedama, but with the
Shader Language as the backend.
	</p>
	<p>
Lately, there are various simulation environments, such as Liquid Fun,
various Box2D based environments.  Nicky Case has a simulation
construction environment based on emoji.  As of now, Shadama uses a
textual language, based on the observation that physics simulations
often only takes concise problem description so coding part is not the
major obstacle.
	</p>
</section>
<section>
	<h2 id="conclusions-and-future-work">Conclusions and Future Work</h2>
	<p>
This is an early prototype of the concept of a simulation language in
which users can make simulations, interactive art and various
visualization.  The liveliness of the environment encourages the
exploratory style of programming, that is handy to try different ideas
quickly.  An anecdotal observation is that bugs in a program often
produces interesting visual effects, and that is motivating.
	</p>
	<p>
We are thinking about various improvements to the system.  One major
addition is to fully support simulations in 3D.  While the numeric
computation itself is all scalar values and agnostic to the
dimensionality, the primitive provided by the system and the concept
of patches only works well for 2D.  New ideas are called for to manage
the spatial data.
	</p>
	<p>
Also, supporting more mathematics, such as vectors and matriices is in
our plans. A first-time user may not use vectors and matrices
initially and write two lines of code for one vector operation, but we
would like them to learn those powerful concepts. Ideally the language
may ramp up the user to use those powerful mathematical tools.
	</p>
</section>

<section>
	<h2 id="language">The Primer of the Shadama Language (The one pager) </h2>
	<p>
The Shadama language uses the turtles and patches abstraction, which
is drawn from the tradition of StarLogo.  Turtles are organized into
"breeds".  Each breed can declare its own variables.

        <h3 id="breeds">Breeds</h3>
  A breed is declared in the program with the "breed" statement.  For example, a
statement:
<pre class="code">
breed MyTurtle (x, y)
</pre>
</p>
<p>
creates a breed of turtle called "MyTurtle", and declares that each
turtle in the breed has two own properties called "x", and "y".
	</p>
	<p>
The type of properties are limited to scalar floats.
	</p>
	<p>
To define behavior for turtles, you define a method with the def
statement.  Here is an example:<br>
<pre class="code">
def move() {
  this.x = this.x + 1;
  this.y = this.y + 1;
}
</pre>
</p>
<p>
Intuitively, when this method is invoked for a turtle, the
turtle's x property and y property are incremented by one.
	</p>
	<p>
When a method is invoked from a static function, all turtles in the receiving breed executes it at the
same time.  For
example, a static function:<br>
<pre class="code">
static step() {
  MyTurtle.move();
}
</pre>
</p>
<p>
calls the move method on all turtles of the MyTurtle breed.  Besides
user-defined methods, there are "primitives" that provide certain
pre-defined features. The following is a list of primitives for
breeds.
<ul>
<li> <code>aBreed.setCount(count);</code>
  <p>
  This sets the number of turtles in the breed.

  For example, a static function:
<pre class="code">
static setup() {
  MyTurtle.setCount(10000);
}
</pre>
	</p>
	<p>
will set the number of turtles in the MyTurtle breed to 10,000.
</p>
<p>
  In the current implementation, there is a limit on the number of
turtles for a breed.  The limit is about 1 million.  (It is provided
by the square of a constant called TEXTURE_SIZE in the
implementation.)
	</p>
<li> <code>aBreed.fillRandom(name, min, max);</code>
	<p>
  The fillRandom primitive sets the property specified by
  the string to be a random (floating point) number between min
  (inclusive) and max (exclusive).  It does not change the number of
  turtles in the breed.  For example,
  <pre class="code">
static setup() {
  MyTurtle.setCount(10000);
  MyTurtle.fillRandom("x", 0, 100);
}
  </pre>
  </p>
  <p>
  will make each of the 10,000 instance's "x" property to be a
  random floating point number between 0 and 100.
 </p>
<li> <code>aBreed.fillRandomDir(dxName, dyName);</code>
	<p>

  The fillRandomDir primitive generates a random 2D unit direction
  vector (that is, a vector pointing to a direction in a 2D space, and
  whose length is one) and store its x and y component of the vector
  into the own property specified by dxName and dyName, respectively.
  For example,
  <pre class="code">
static setup() {
  MyTurtle.setCount(10000);
  MyTurtle.fillRandomDir("dx", "dy");
}
</pre>
</p>
<p>
sets "dx" and "dy" of a turtle with the x- and y- component of a random unit vector.
</p>
<li> <code>aBreed.fillSpace(xName, yName, xDim, yDim);</code>
	<p>
The fillSpace primitive first sets the number of turtles in the breed
to be xDim * yDim.  Then, it places the turtles at all 2D grid points
within the (0..xDim, 0..yDim) area.  For example,
<pre class="code">
static setup() {
  MyTurtle.fillSpace("x", "y", 100, 100);
}
</pre>
</p>
<p>
creates 10,000 turtles of the MyTurtle breed, and their "x" and "y" properties become the integral grid points spanned in (0, 0) and (99, 99) (inclusive).
</p>
<li> <code>aBreed.fillImage(xName, yName, rName, gName, bName, aName, anImageData);</code>
	<p>
  The anImageData argument is a Javascript ImageData object.  This
  sets the turtle count of the breed to be anImageData.width *
  anImageData.height.  Then, similar to fillSpace, it places those turtles
  at the 2D grid points within the image extent, and update their own
  variables specified by rName, gName, bName, and aName with the RGBA
  color component values of the image.  Note that while the color
  components in the ImageData ranges from 0 and 255 (integral values),
  the color value in Shadama is normalized to the 0.0 and 1.0 range
  (inclusive).  For example,
<pre class="code">
breed MyTurtle (x, y, r, g, b, a)
static setup() {
  MyTurtle.fillImage("x", "y", "r", "g", "b", "a", anImage);
}
</pre>
</p>
<p>
(where the value of anImage can be taken from the global variable
described below), creates the same number of turtles to the pixel
count of anImage, and stores the anImage's color component values,
scaled to 1.0, into r, g, b and a properties.
</ul>

<h3 id="breeds">Patches</h3>
<p>
Besides breeds of turtles, you can create patches.  A patch
is a set of "cells" that can hold values.  A patch
assumes a two-dimentional space of the fixed size (by default
512x512, specified as FIELD_WIDTH and FIELD_HEIGHT).
For example, a statement:
<pre class="code">
patch Field (nx, ny)
</pre>
</p>
<p>
declares a patch, and each cell in the patch variable holds
two values "nx" and "nyclas".
</p>

<p>
To manipulate patches, you  pssed them into a method as arguments.
</p>
<p>
The caller of a method is always a static function.  To pass in a
patch to a method, you pass the name of the patch as an argument.
Each turtle that executes the method can only see the nearest patch
cell, and accessing a property of patch give the value in the cell.
For example, this code:
</pre class="code">
breed MyTurtle (x, y, r, g, b, a)
patch Field (r, g, b, a)

def store(field) {
  field.r = this.r;
}

static setup() {
  MyTurtle.fillImage("x", "y", "r", "g", "b", "a", anImage);
  MyTurtle.store(Field);
}
</pre>
</p>
<p>
declares a breed called MyTurtle and a patch called Field.
The "setup" function calls the "store" method with "Field" as an
argument.  The store method, executed for each turtle in Turtle,
store the turtle's r property into the r property of the nearest cell in Field.
</p>

<p>
You can read values out from the patch.  For example, when the following method is executed:
<pre class="code">
def load(field) {
   this.r = field.r;
}
</pre>
</p>
<p>
each turtle reads the r property of the nearest patch cell and stores it into its property.
</p>
<p>
You can pass in multiple patches to a method.  For example,
<pre class="code">
patch Field1 (nx, ny, r, g, b, a)
patch Field2 (nx, ny, r, g, b, a)
def transfer(f1, f2) {
  f2.r = f1.r;
  f2.a = f1.a;
}
</pre>
</p>
<p>
and even
<pre class="code">
def swap(f1, f2) {
  f2.r = f1.r;
  f1.r = f2.r
}
</pre>
</p>
<p>
are valid.
</p>

<h3 id="variables">Local and Global Variables</h3>
<p>
A method can have local variables declared by the "var"
statement.  The scope of the variable is the whole method,
regardless where it is declared.  There can be at most one "var"
declaration for the saem variable name, unlike JavaScript.
</p>
<p>
Static functions have global variables, which are visible to all static functions.
For example, if you have two static functions:
<pre class="code">
static setup() {
  var begin = 1;
}

static loop() {
  if (begin) {
    begin = 0;
  }
}
</pre>
</p>
<p>
The begin variable can be referred to from both setup and loop,
</p>

<p>
There are built in global variables.
</p>
<ul>
<li> <code>mousemove</code>: an object which has property x and y
<li> <code>mouseup</code>:  an object which has property x and y
<li> <code>mousedown</code>: an object which has property x and y
<li> <code>time</code>:       a floating point value in seconds since the last time a specially named metho setup is called.
<li> <code> width, height</code>: the width and height of the visible 2D space.
<li> <code>Display</code>:           a stand in to be a left of the dot notation
</ul>
<p>
Note that mouse events are JS objects but methods can still only takes scalar values.

<h3 id="parallelism">Parallelism</h3>
<p>
When turtles are writing into a patch, it is
possible that more than one turtles are at the same cell and try to
write into it.  The result from this is non-deterministic.
</p>
<p>
Also, you cannot read a value that you "just" wrote within the same
method.  For example, if you have a function that looks like:
<pre class="code">
def test() {
  if (this.r > 0) {
     this.r = 0;
  } else {
     this.r = 1; 
  }
  this.b = this.r;
}
</pre>
</p>
<p>
the r property and b property will not have the same value after the invocation,
even though the last line reads <code>this.b = this.r;</code>.  The assignments into this.r in the if statement negates the value, but the actual update of the variable
does not take effect until the function finishes.
</p>
<p>
If you want it so that this.b and this.r will always have the same value, you
can use a local variable and write the above code as:

<pre class="code">
def test() {
  var r = this.r;
  if (r > 0) {
     r = 0;
  } else {
     r = 1; 
  }
  this.r = r;
  this.b = r;
}
</pre>

</p>

<h3 id="control-structure">Control structure</h3>
<p>
Only control structure supported is the if statement.  As GLSL 3.0
supports variable-count loops, Shadama should be able to support
loops; but it has not implemented.
</p>
<p>

<h3 id="function-primitives">Function Primitives</h3>
<p>
There are number of functions available from
methods.  Most of them actually result in a direct call
to the GLSL built-in functions.  For example, 

<pre class="code">
def prims(x) {
  var c = cos(x);
  var s = step(0.5, x);
  var a = abs(x);
  var f = fract(x); // the fraction part of x
  
  this.r = c * s * a * f;
}
</pre>
</p>
<p>
computes a value successfuly (though an arbitrary value) and stores it into the r variable.
</p>

<h3 id="otherlimitations">Other Limitations</h3>
<p>
There are some limitations, and some of which are even idyosynchratic.
One limitation is that one method can take patch variables or scalar
values but not other turtles.  For example, you cannot execute the
following code:

<pre class="code">
breed A (x, y)
breed B (x, y)

def hit(other) {
  var diff = other.x - this.x;
  ...
}

static step() {
  A.hit(B);
}
</pre>
</p>
<p>
because the "step" static function calls "hit" with a breed as
argument.  It is not a sensible program, anyway: which instance of B
should be bound to "other"?
</p>
<p>
Another limitation is that you cannot write into an own variable of
this *and* a patch's own from the same method.  For example, the
following is invalid:
<pre class="code">
def test(field) {
  field.r = 1;
  this.r = 1;
}
</pre>
</p>
<p>
This imitation is derived from the implementation consideration on
current WebGL features and may be lifted in the future.  Also, by
doing more code analysis, it may be made possible to aleviate the
limitation.  But for the time being, you need to split this kind of
function into two, each only write into either patches' own variables,
or own variables of "this".
</p>

<h3 id="other-notes">Other Notes</h3>
<p> 
Methods are not bound to a breed.  The "set" method below:
<pre class="code">
breed A (x, r)
breed B (x, y, r, g)
breed C (r)

def set() {
  this.r = 1;
  this.x = 0;
}

static test() {
  A.set();
  B.set();
}
</pre>
</p>
<p>
can be called both for breed A and breed B, but not breed C, because
its only requirement is that the breed has own variables called "r"
and "x", which are referred to from the function.
</p>
</section>

      <section>
        <h2>References</h2>
	<ul>
	  <li>StarLogo
	  <li>LiquidFun
	  <li>GLSL
	  <li>Nigiri
        </ul>
      </section>
    </article>
  </body>
</html>
