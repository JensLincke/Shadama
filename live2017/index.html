<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Shadama: A Particle Simulation Programming Environment for Everyone</title>
    <link rel="stylesheet" href="tufte.css"/>
    <link rel="stylesheet" href="latex.css"/>
    <link rel="stylesheet" href="style.css"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <script>
var shadamaEvents = [
    [`Our first example of Shadama is a simple physics simulation of particles and gravity.`, 0], 
    [`As in the LOGO programming language, we refer to mobile objects as turtles. Here, we 
      declare a breed of turtle such that each turtle will have properties
      "x", "y", "r", "g", "b" and "a".`, 5],
    [`A method is defined with the keyword "def". Methods are executed on
each turtle in a breed. Here, we've defined the "setColor" method to use the turtle's x and y
coordinates to assign them a red and green value.`, 15],
    [`In the static function "setup", we set the number of
turtles in the breed to be 3,000 and then set all turtle's x and y coordinates to be a
random number between 0 and 512. We run "setup" by hitting Cmd-S.`, 27],
    [`Those dots may be hard to see, but we can increase the number of turtles
to 30,000, 300,000 or 1 million.`, 38],
    [`What we want to do next is to move those turtles around. So we define
a method called "move". Move increments the x and y of the turtles. We call
the move method from a static function "step".`, 50],
    [`When we click the "step" clock, "step" is repeatedly executed and the turtles move.`, 61],
    [`Interestingly, while they are moving, we can edit the program on the
fly and the changes take effect as soon as we hit Cmd-S. We can add an
argument to "move", use it in the code, change the call site and the
turtles that went off screen come back.`, 66],
    [`We could even allow each individual turtle to have its own
velocity. So let's add properties "dx" and "dy" to each turtle. Then, we use them in
"move". Here, instead of "n", we increment the "x" and "y" of each turtle
according to their "dx" and "dy".`, 90],
    [`We call the primitive "fillRandom" to set the "dx" and "dy" to be the x and y components
of a randomly-chosen direction vector. Now, all turtles move
in their own individual directions.`, 107],
    [`Let's run it again by executing "setup" manually.`, 120],
    [`Now we'll change this to be a simple gravity simulation. To do so, we add constant
acceleration to the "y" component of the velocity.  Now all turtles are
accelerating toward the bottom.`, 125],
    [`We don't want those particles to go out of bounds. So we modify
the "move" method. First we store "dx" and "dy", as well as the possible
new location of "x" and "y" into local variables.`, 135],
    [`When "newX" is out of bounds, we make the turtle bounce back.`, 145],
    [`When "newY" is out of bounds below, we wrap the value around to the top.`, 152],
    [`After adjusting those variables,
we write the values back to the turtle's properties. Now one million
turtles are falling down, bouncing off the side walls, and wrapping around
to the top.`, 160],
    [`We are now going to create a simulation with large objects. To do so, we use what's called a "patch". A
patch is a 2D grid of cells where turtles can store values. Here,
we create a patch called "Field", and add "r", "g", "b", and "a" properties for each cell.`, 176],
    [`And, we define a breed called "Filler" that operates on the Field.`, 197],
    [`Now we define a method called "fill". The argument for this method is the patch, and
turtles executing this method update the patch cell value at their x and y coordinates.`, 203],
    [`We modify "setup" to use a primitive called
"fillSpace", which creates turtles of the Filler breed and
places them at all integral grid points. When this "setup" is called,
and the "fill" method is called, each "r" and "g" of the patch get values derived from its position, resulting 
in this color gradient.`, 214],
    [`Let's make some shapes now. We define
the "fillCircle" method to replace "fill". Let's also add the "clear" method, which clears the field's values.`, 231],
    [`"fillCircle" works by having each Filler turtle
check whether it is within the radius of the circle. If it is, it writes
the value into their corresponding cell.`, 244],
    [`In the "setup" function, we call "fillCircle" and get a circle at (100, 100).`, 264],
    [`Shadama programs can also be interactive. Let's split the "setup" function and
create another one called "loop".`, 273],
    [`Notice to the right that there is a variable
called "mousemove", which changes its value as we move the mouse pointer in the
display. That is an indication that we can use the value in our
program.`, 288],
    [`Now let's tie it all together. This code has methods we used
previously, such as "setColor". "fillCircle" is slightly modified so that
it sets normal vectors for the circle in the patch.`, 308],
    [`In the "move"
method, each turtle checks the normal in the patch cell where the turtle is
located and computes a new direction from the dot product with the normal. When we run
this, particles bounce off the circle and make a beautiful pattern.`, 320],
    [`However, it is a bit hard to see because the colors of the turtles are too
similar. Here, we change the "setColor" method so that instead of using "x"
and "y" position, we use the velocity "dx" and "dy" to determine the turtles'
color.`, 348],
    [`Then we call "setColor" from "loop", so that the colors are updated continuously.`, 360],
    [`Here, horizontal velocity corresponds with reddish color, and vertical
velocity corresponds with greenish color. The visualization can be quickly adjusted
to match how you prefer to view the simulation.`, 365], 
    [`For fun, you can make two circles that move symmetrically.`, 375],
    [`Here's an interesting variation of our program. Instead of modeling gravity as pulling downward, gravity follows
the inverse square law in relation to the mouse pointer location. It looks like
there are large structures, but it's actually just a
quarter million particles from regular initial positions, all following the inverse square law.`, 384],
    [`Shadama allows the user to import images. The built-in "fillImage"
takes an image object, creates enough turtles to cover it, and sets the turtle colors
based on the image's pixel values. This looks like an image but it is
actually a bunch of turtles.`, 422],
    [`We reuse our previous "move" method, set the
direction vectors randomly, create the "loop" method that calls "move", and run "loop".`, 442],
    [`For fun,
We can use the turtles' red and green values to determine turtle velocity, causing an
an interesting effect.`, 466],
    [`Let's use those pixels in our gravity simulation.`, 488],
    [`The code checks the timer, and every 10 seconds, it gathers all turtles to their original position.`, 500],
    [`We can also try some mathematical functions. This is a program to
visualize the Mandelbrot set. Notice how we can change the color scheme on the
fly.`, 511],
    [`This is Conway's Game of Life.`, 532],
    [`Again, we can change the program while
the simulation is running, and the code change is reflected in the
simulation right away, without needing to restart.`, 537]];
    </script>
    <script>
       var eventDivs; // [[div, time]]

       var transcript;
       var interval;
       var caption;

       function processOne(event) {
	   var p = document.createElement("div");
	   p.innerHTML = "<p class='caption'>" + event[0] + "</p>";
           caption.appendChild(p);
	   return [p, event[1]];
       }

       /* YouTube Javascript API stuff */
       var tag = document.createElement('script');
       tag.src = 'https://www.youtube.com/iframe_api';
       var firstScriptTag = document.getElementsByTagName('script')[0];
       firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
       var player;
       function onYouTubeIframeAPIReady() {
	   player = new YT.Player('player', {
	       height: '576',
	       width:  '1024',
	       videoId: 'kHTIv7HUPt8',
	       events: { 'onStateChange': onPlayerStateChange },
	       playerVars: {rel: 0, showinfo: 0},
	   });
       }
       function onPlayerStateChange(e) {
	   if (e.data == YT.PlayerState.PLAYING) {
	       interval = window.setInterval(updateEventHighlight, 500); // update every half-second
	       updateEventHighlight();
	   }
	   if (e.data == YT.PlayerState.ENDED  ||
               e.data == YT.PlayerState.PAUSED ||
               e.data == YT.PlayerState.BUFFERING) {
	       window.clearInterval(interval);
	   }
       }

       function findEvent(time, events) {
         for (var i = 0; i < events.length - 1; i++) {
	     var pair = events[i];
	     var next = events[i+1];
             if (pair[1] <= time && time < next[1]) {
		 return pair[0];
	     }
	 }
	 var pair = events[events.length -1 ];
         if (pair[1] < time) {
	     return pair[0];
	 }
       }

       function updateEventHighlight() {
	   Array.from(document.getElementsByClassName('highlight')).forEach(function (p) {
	       p.classList.remove('highlight');
	   });
	   var time = parseFloat(player.getCurrentTime());
	   var event = findEvent(time, eventDivs);
	   if (!event) {
	       return;
	   }
	   caption.scrollTop = event.offsetTop - eventDivs[0][0].offsetTop;
	   event.firstChild.classList.add("highlight");
       }

       function initialize() {
	   caption = document.getElementById("caption");
	   eventDivs = shadamaEvents.map(processOne); // [[div, time]]  As a side-effect it adds divs to caption
       }
       onload = initialize;
  </script>
  </head>
  <body>
    <article>
      <h1 id="title">Shadama: A Particle Simulation<br> Programming Environment for Everyone</h1>
      <p class="subtitle">Yoshiki Ohshima, Dan Amelang and Bert Freudenberg<br>
      HARC/Y Combinator Research</p>

      <section id="abstract">
        <p>
We present a prototype of a programming system called Shadama.
Shadama is designed for writing programs that create, control and visualize large numbers of objects.
The basic execution model follows the tradition of StarLogo and its "turtles and patches" abstraction.
<label for="sn-starlogo"
       class="margin-toggle sidenote-number">
</label>
<input type="checkbox"
       id="sn-starlogo"
       class="margin-toggle"/>
<span class="sidenote">
<a href="#starlogo">M. Resnick, Turtles, Termites, and Traffic Jams: Explorations
in Massively Parallel Microworlds (Complex
Adaptive Systems). MIT Press, 1994.<br>
<img src="starlogo-book.jpg" width="50%" height="50%" style="margin-left: 20.2%"/>
</a>
</span>
&nbsp; This abstraction has been proven to be effective and easy to use.
The primary goal of the language is to facilitate the writing of scientific simulations by students
at the high school level.
	</p>

        <p>
The Shadama environment supports <i>liveness</i>.
Once changes to the program are saved, the effect on the running simulation is immediate.
There is no need to restart the simulation.
	</p>
        <p>
Shadama programs are run on the GPU by means of code translation to the OpenGL Shading Language.
<label for="sn-glsl"
       class="margin-toggle sidenote-number">
</label>
<input type="checkbox"
       id="sn-glsl"
       class="margin-toggle"/>
<span class="sidenote">
<a href="#glsl">OpenGL Shading Language</a>
</span> &nbsp;
Program data resides entirely on the GPU, which enables high performance.
	</p>

        <p>
A prototype of Shadama can be found <a href="http://tinlizzie.org/~ohshima/shadama2">here</a>.
Be aware that Shadama requires WebGL 2 and is affected by the floating point precision provided
by your graphics card. Thus, it only works on certain computer systems.
From our experience, it seems to work better on computers with an AMD Radeon graphics
card and on Chrome or Firefox browsers.
</p>
      </section>
      <section>
        <h2>Introduction</h2>
        <p>
The computing power available to us today is astounding.  Achieving
one teraflop of performance was a milestone for a building-sized supercomputer in
the late '90s, but now we expect smart phones to reach this same milestone soon.
Computing performance will only continue to increase in the future.
	</p>
	<p>
But what are people using this power for?  Not to be critical, but
people are generally more interested in watching cat videos and
playing games than trying to invent self-piloting personal airplanes
or discover the graviton.

All joking aside, one of the big problems we face today is our
struggle to advance science literacy, even within a
technologically-advanced society.  We need the next
generation to embrace science more, not less.
	</p>
	<p>
We think now is a good time to redouble our efforts to provide
environments where students, artists, and even professional
programmers can tap into the computing power that is available.
	</p>
	<p>
To this end, we have been working on a prototype of a
programming language intended for high school students to explore
scientific concepts.
	</p>
	<p>
  Science is about making the invisible visible.  One notable example
of an invisible yet important concept is molecules in a gas.  We would
like students to learn about this, not by rote memorization, but
through actual experiments and model-building.  With the help of
computers, students can make a dynamic model and understand it more
deeply.  This kind of environment will help students construct
knowledge by doing, in line with the constructivism philosophy of
education.
	</p>
</section>

<section>
	<h2 id="a-science-experiment">A Science Experiment</h2>
  <br>
<iframe width="640" height="360" src="https://www.youtube.com/embed/07D0nB3mgLA" frameborder="0" allowfullscreen></iframe>
	<p>
Before going into the detail of the programming system, we would like
to show one of the examples students would try as a physics
experiment, that later may be modeled and simulated on computer.
</p>
<p>
This movie shows a vacuum cannon.  The cannon is a six foot PVC
pipe connected to a vacuum pump.  We put a ping pong ball inside the pipe,
cover the ends with sturdy but breakable material (such as plastic plates),
and pump the air out.
	</p>
	<p>
The pump reduces the pressure inside the tube to about 20% of full atmospheric pressure.
	</p>
	<p>
When the end near the ping pong ball is broken open by a box cutter, the
air molecules that rush into the pipe move into the
low pressure space and the ping pong ball is pushed out the other end.
Our crude setup can accelerate the ball to a speed of over 200 meters per second
(about 60% of the speed of sound).  Others have built similar setups
that can achieve supersonic speed.
	</p>
        <p>
An interesting point to understand is that it is just movement of
molecules that is causing the ball to shoot out. It is not that the
vacuum is sucking molecules into the pipe.
</p>
<p>
The invisible molecules that cause the ball to shoot out can
be made &ldquo;visible&rdquo; in a sense not only through this physical experiment,
but also through a computer simulation that reproduces the same phenomenon.
Creating such simulations is the purpose of our programming environment.
	  </p>
</section>

<section>
	<h2 id="language-goals">Language Goals</h2>

<p>
We had the following goals when designing Shadama:
<ul>
<li> Easy to learn</li>
<li> Support for large numbers of particles</li>
<li> Liveness</li>
</ul>
</p>

<p>
To make learning Shadama easy, we based our language on StarLogo,
whose turtles and patches approach has proved intuitive to young learners.
In addition, we expect students familiar with Scratch to
learn Shadama easily because of similarites in how object behavior
is programmed and how objects can sense values near them spatially.
</p>

<p>
To support large numbers of particles, we designed the language
to execute on graphics hardware. Graphics processors today
are capable of computing on massive amounts of data.
Unfortunately, this requires a trade-off between ease of use and
high performance, because there are fundamental limitations in
the execution model of today's graphics hardware.
Although Shadama has some features to mitigate these limitations,
certain behaviors cannot be implemented.
</p>

<p>
To provide liveness, we designed the Shadama environment to show
the effects of code changes immediately. Of course,
a running simulation should not be updated for each and every key stroke.
Instead, the user submits a batch of code changes for the environment
to apply.
</p>

</section>

<section>
	<h2 id="shadama-in-Action">Shadama in Action</h2>
	<p>
The following movie shows some examples using our prototype programming environment called Shadama.

The script below provides an explaination of the movie.  You can pause the movie at any time to scroll through and read the explanation.  The captions work better when the movie is not in full screen.
	</p>
  <div id="video">
    <div id="player"></div>
  </div>
  <div id="caption" class="caption"></div>
  <hr>
</section>
<section>
	<h2 id="implementation">Implementation</h2>
</section>
<p>
<!-- We could say a lot more about implementation here, such as how the OpenGL pipeline is used,
     what type of shaders are generated, etc. -->
Shadama is built on web technologies, including WebGL 2.0 and OpenGL
Shading Language version 3.0. All the values for a given property and breed
are stored in a single OpenGL texture. All textures have the OpenGL "R32F"
type to best match their use as a vector of scalar values.
Methods that write to multiple properties are implemented using the
multiple render targets feature of OpenGL.
</p>
<p>
Our code translator is written in Ohm and generates vertex shader,
fragment shader and JavaScript code from the Shadama program.
<label for="sn-ohm"
       class="margin-toggle sidenote-number">
</label>
<input type="checkbox"
       id="sn-ohm"
       class="margin-toggle"/>
<span class="sidenote">
<a href="#ohm">Ohm: A library and language for building parsers, interpreters, compilers, etc.</a>
</span>
</p>
<p>
As described in the movie and appendix below, turtles behavior is
described in methods.  The compiler analyzes the method code,
construct the list of input and output properties.  The used
properties are passed in via the texture units.
</p>
<p>
The computation in a method is translated to the vertex shader code.
A turtle is logically identified by the attribute
(called <code>a_index</code>) of a vertex, which is a vec2 value that
specifies an integral grid point used to index into a texture that
represents a property of a breed.  The translated vertex shader code
fetches the texel based on the <code>a_index</code> from textures by
using <code>texelFetch()</code>, executes the computation, and passes
the resulting values to be written back textures to the generated
fragment shader code.  The fragment shader code uses the multiple
render target (MRT) feature of GLSL 3.0 and simply write the values
into designated textures.
</p>

<section>
	<h2 id="related-work">Related Work</h2>
	<p>
Previously, one of the authors implemented a particle system called Kedama as an extension of Etoys.
<label for="sn-kedama"
       class="margin-toggle sidenote-number">
</label>
<input type="checkbox"
       id="sn-kedama"
       class="margin-toggle"/>
<span class="sidenote">
<a href="#kedama">
Kedama: A GUI-Based Interactive Massively Parallel Particle Programming System.<br>
<img src="kedama.png" width="50%" height="50%" style="margin-left: 20%" alt="Kedama screenshot" /></a><br>

</span> &nbsp;    Shadama can be considered an attempt to give the same idea new life.
Kedama's target audience was middle school children, while Shadama's target audience is high school students.
	</p>
	<p>
The biggest inspiration for Shadama (and Kedama) was Resnick's StarLogo.
The basic organization of Shadama objects is largely based upon StarLogo.
However, StarLogo has certain features that Shadama does not, as mentioned in the introduction.
	</p>
	<p>
Based on Extempore, Swift et al. created a live programming environment for physics.
<label for="sn-extempore-pic"
       class="margin-toggle sidenote-number">
</label>
<input type="checkbox"
       id="sn-extempore-pic"
       class="margin-toggle"/>
<span class="sidenote">
<a href="#extempore">Live Programming in Scientific Simulation<br>
<img src="extempore-pic.png" width="50%" height="50%" style="margin-left: 20%" alt="Extempore PIC demo screenshot" /></a><br>
</span> &nbsp;
This environment brings dynamic code swapping and interactive data inspection to
a sophisticated and optimized particle-in-cell simulation framework.
The spirit of this work is much in line with
ours, except that their environment depends on a third-party engine as a black box.
We believe that such an engine should instead be accessible to the user.
	</p>
	<p>
Although many simulation environments such as Liquid Fun
<label for="sn-liquidfun"
       class="margin-toggle sidenote-number">
</label>
<input type="checkbox"
       id="sn-liquidfun"
       class="margin-toggle"/>
<span class="sidenote">
<a href="#liquidfun">LiquidFun.<br>
<img src="liquidfun.png" width="50%" height="50%" style="margin-left: 20%" alt="LiquidFun screenshot" /></a>
</span>
are available today, they do not provide an end-user language.
</p>
<p>

Nicky Case has a simulation construction environment based on emoji.
<label for="sn-emoji"
       class="margin-toggle sidenote-number">
</label>
<input type="checkbox"
       id="sn-emoji"
       class="margin-toggle"/>
<span class="sidenote">
<a href="#emoji">Simulation in Emoji<br>
  <img src="emoji.png" width="50%" height="50%" style="margin-left: 20%" alt="Simulation in Emoji screenshot" /></a>
</span>  &nbsp; The design and the style of the system has nice and friendly for end-users to try different models and simulations.  By design, however, the number of cells and objects are limited to a few hundreds, but not millions.
</p>
<p>
Programming the GPU from a high-level language is a hot topic.
<label for="sn-ikra"
       class="margin-toggle sidenote-number">
</label>
<input type="checkbox"
       id="sn-ikra"
       class="margin-toggle"/>
<span class="sidenote">
<a href="#ikra">Object Support in an Array-based GPGPU Extension for Ruby (ARRAY’16)</a>
</span>&nbsp;  Researchers in this area aim for better performance through
increasingly sophisticated compilation techniques and the use of the CUDA API to more directly access the GPU.
Ease of use is given little consideration.
The authors think that Shadama can occupy a unique position
by striking a better balance between performance and ease of use.
	</p>
	<p>
Some languages for programming massively parallel particle simulations
are based on visual programming blocks.
StarLogo Nova is a notable example.
<label for="sn-slnova"
       class="margin-toggle sidenote-number">
</label>
<input type="checkbox"
       id="sn-slnova"
       class="margin-toggle"/>
<span class="sidenote">
<a href="#slnova">StarLogo Nova</a>
</span>
Shadama is currently text-based because we feel that physics simulations
can be naturally expressed with concise text.
However, we have not ruled out other possiblities for syntax,
including a visual representation of the program.
	</p>
</section>

<section>
	<h2 id="conclusions-and-future-work">Conclusions and Future Work</h2>
	<p>
We have presented an early prototype of a language in
which users can make enlightening simulations and intricate visualizations.
The liveliness of the environment encourages an
exploratory style of programming that enables trying out different ideas quickly.
We have also discovered that such an interactive and graphical environment
can be motivating even as bugs appear, because of the spectacular
unintentional visual effects that are produced.  In other words, the results often have eye-pleasing, fun quality.
	</p>
	<p>
We are considering various improvements to the system.  One major
addition would be to fully support simulations in 3D, not just 2D.
While computation in Shadama only uses scalar values and is agnostic to dimensionality,
the primitives and concepts the system provides only work well currently for 2D applications.
We will need new ideas to manage 3D spatial data.
	</p>
	<p>
We also plan to support more mathematical concepts, such as vectors and matrices.
While first-time users may not have use for such abstractions initially,
we would like them to eventually learn and use these powerful concepts. 
Ideally, the environment would gradually introduce the user to new, more difficult approaches.
	</p>
	<p>
We would like to conclude this report by stressing the importance of
education. Education raises our awareness and enables us to see our world from new perspectives.
Thus, we are empowered with new approaches to solve problems.
This is particularly true in the case of science education, which motivates this work.
<!-- HARC's mission to ensure human wisdom exceeds human power,
by inventing technology that allows all humans to see further and understand more deeply.-->
	</p>
</section>

      <section>
        <h2>References</h2>
	<ol type="1">
	  <li id="starlogo">
M. Resnick, Turtles, Termites, and Traffic Jams: Explorations
in Massively Parallel Microworlds (Complex
Adaptive Systems). MIT Press, 1994.
          </li>
	  <li id="glsl">OpenGL Shading Language (<a href="https://khronos.org/registry/OpenGL/">OpenGL Registry</a>)</li>
          <li id="ohm">Ohm: A library and language for building parsers, interpreters, compilers, etc. (<a href="https://ohmlang.github.io/">project page</a>)
	    <li id="kedama">Kedama: A GUI-Based Interactive Massively Parallel Particle Programming System: Yoshiki Ohshima.  VL/HCC 2005, pp 91-98.</li>
          <li id="extempore">Live Programming in Scientific Simulation: Ben Swift, Andrew Sorensen, Henry Gardner, Peter Davis, Viktor K. Decyk, Supercomputing Frontiers and Innovations, p. 4-15, Mar. 2016. (<a href="http://superfri.org/superfri/article/view/72">Journal page</a>)</li>
	  <li id="liquidfun">LiquidFun: (<a href="http://google.github.io/liquidfun/">the project page</a>)</li>
          <li id="emoji">Simulation in Emoji: Nicky Case, (<a href="http://ncase.me/simulating/model/">project page</a>)</li>
	  <li id="ikra">Matthias Springer and Hidehiko Masuhara, Object Support in an Array-based GPGPU Extension for Ruby Proceedings of the 3rd ACM SIGPLAN International Workshop on Libraries, Languages, and Compilers for Array Programming (ARRAY’16), June 2016</li>
	  <li id="slnova">StarLogo Nova (<a href="http://slnova.org/">project page</a>)</li>
        </ol>
      </section>
<section>
	<h2 id="language">Appendix: A Primer for the Shadama Language</h2>

<p>
<!-- The rest of this paragraph contained content that is properly introduced later. As it was,
     it was confusing because it assumed the reader already understood terms that aren't introduced yet -->
The Shadama language uses a breed of turtles and patches abstraction, drawn from the tradition of StarLogo.
</p>

        <h3 id="breeds">Breeds</h3>
<p>
Turtles are organized into
"breeds".  Each breed has its own set of properties.
A breed is declared in a program with the "breed" statement.  For example:
</p>
<pre class="code">
breed MyBreed (x, y)
</pre>
<p>
creates a breed of turtle called <code>MyBreed</code>, and declares that each
turtle in the breed has individual properties <code>x</code> and <code>y</code>.
</p>
<p>
Currently, properties in Shadama can only be scalar floating-point numbers.
</p>
<p>
Methods provide turtle behavior. The <code>def</code> statement is used to define
methods, as follows:
</p>
<pre class="code">
def move() {
  this.x = this.x + 1;
  this.y = this.y + 1;
}
</pre>
<p>
As expected, when this method is invoked on a turtle, the
turtle's x and y properties are incremented by one.
</p>
<p>
Methods are invoked from static functions. Methods are invoked
by first specifying a breed, then the method name.
The method is applied to all turtles in the breed concurrently.
For example:
</p>
<pre class="code">
static step() {
  MyBreed.move();
}
</pre>
<p>
The <code>step</code> function above calls the <code>move</code> method on all turtles of the <code>MyBreed</code> breed.
</p>

<p>
Shadama provides many built-in features made available through primitive methods:
</p>
<ul>

<li> <pre class="primitive">aBreed.setCount(count);</pre>
  <span>
  The <code>setCount</code> primitive sets the number of turtles in the breed.
For example:
</span>
<pre class="code">
static setup() {
  MyBreed.setCount(10000);
}
</pre>
<span>
Invoking this static function will set the number of <code>MyBreed</code> turtles to 10,000.
In the current implementation, the number of turtles in a breed is limited to
1024 × 1024, or about 1 million.
</span>
</li>

<li> <pre class="primitive">aBreed.fillRandom(name, min, max);</pre>
<span>
  The <code>fillRandom</code> primitive sets the property specified by <code>name</code>
  to be a random number between <code>min</code>
  (inclusive) and <code>max</code> (exclusive) for each turtle in the breed.
  For example:
</span>
<pre class="code">
static setup() {
  MyBreed.setCount(10000);
  MyBreed.fillRandom("x", 0, 100);
}
</pre>
<span>
  The above will set each of the 10,000 turtles <code>x</code> property to be a
  random floating-point number between 0 and 100.
</span>
</li>

<li> <pre class="primitive">aBreed.fillRandomDir(dxName, dyName);</pre>
<span>
  The <code>fillRandomDir</code> primitive generates random 2D unit vectors.
  This is done for each turtle, and the x and y components of the result are stored
  in the properties <code>dxName</code> and <code>dyName</code> of the turtles.
  For example:
</span>
<pre class="code">
static setup() {
  MyBreed.setCount(10000);
  MyBreed.fillRandomDir("dx", "dy");
}
</pre>
<span>
The above sets the <code>dx</code> and <code>dy</code> properties of the turtles with the x and y components of the randomly generated unit vectors.
</span>
</li>

<li> <pre class="primitive">aBreed.fillSpace(xName, yName, xDim, yDim);</pre>
	<span>
The fillSpace primitive first sets the number of turtles in the breed
to be <code>xDim</code> × <code>yDim</code>.  Then, it places the turtles on integral 2D grid points
within the (0..<code>xDim</code>, 0..<code>yDim</code>) area, storing into the <code>xName</code> and <code>yName</code> turtle properties.
For example:
</span>
<pre class="code">
static setup() {
  MyBreed.fillSpace("x", "y", 100, 100);
}
</pre>
<span>
The above creates 10,000 turtles of the MyBreed breed, setting the turtle's <code>x</code> and <code>y</code> properties
to be the integral grid points spanning (0, 0) to (99, 99), inclusive.
</span>
</li>

<li> <pre class="primitive">aBreed.fillImage(xName, yName, rName, gName, bName, aName, anImageData);</pre>
	<span>
  The fillImage primitive converts a 2D image into a breed of turtles.
  The <code>anImageData</code> argument is a Javascript ImageData object containing the data used
  to populate the breed. The turtle count is set to be <code>anImageData.width</code> × <code>anImageData.height</code>.
  Similar to <code>fillSpace</code>, the turtles are placed on the 2D grid points within the image extent.
  The turtle properties given by <code>rName</code>, <code>gName</code>, <code>bName</code>, and <code>aName</code> are populated with the RGBA
  color component values of the image. Note that while the color components in <code>anImageData</code> range
  from 0 and 255 (integral values), the values in Shadama will be normalized to range from 0.0 and 1.0,
  inclusive (floating-point).
  For example:
<pre class="code">
breed MyBreed (x, y, r, g, b, a)
static setup() {
  MyBreed.fillImage("x", "y", "r", "g", "b", "a", anImage);
}
</pre>
</span>
<span>
(Global variables, such as <code>anImage</code>, are described below.)
</span>
</ul>

<h3 id="patches">Patches</h3>

<p>
A patch is a 2D set of cells that store values.
Patches are fixed size, 512 × 512 by default.
The following declares a patch:
<pre class="code">
patch Field (nx, ny)
</pre>
</p>
<p>
Each cell in this patch stores two values, <code>nx</code> and <code>ny</code>.
</p>

<p>
A patch can be manipulated by passing it as an argument to a method on a breed.
As the method is executed for each turtle, turtles can access the patch cell
nearest them. No other patch cells are available to them.
For example:
<pre class="code">
breed MyBreed (x, y, r, g, b, a)
patch Field (r, g, b, a)

def store(field) {
  field.r = this.r;
}

static setup() {
  MyBreed.fillImage("x", "y", "r", "g", "b", "a", anImage);
  MyBreed.store(Field);
}
</pre>
</p>
<p>
The above declares a patch called Field which is used as an argument to <code>store</code>.
When <code>store</code> is executed for each turtle in <code>MyBreed</code>, the turtle's <code>r</code> property
is stored in <code>r</code> property of the nearest cell in Field.
</p>

<p>
A turtle can read values from patch cells as well.  For example:
<pre class="code">
def load(field) {
   this.r = field.r;
}
</pre>
</p>
<p>
When the above method is executed, each turtle reads the <code>r</code> property of the nearest patch cell
and stores the value into its own <code>r</code> property.
</p>
<p>
Methods can receive multiple patches as arguments.
For example:
<pre class="code">
patch Field1 (nx, ny, r, g, b, a)
patch Field2 (nx, ny, r, g, b, a)
def transfer(f1, f2) {
  f2.r = f1.r;
  f2.a = f1.a;
}
</pre>
</p>
<p>
The following code is also valid:
<pre class="code">
def swap(f1, f2) {
  f2.r = f1.r;
  f1.r = f2.r
}
</pre>
</p>

<h3 id="variables">Local and Global Variables</h3>
<p>
The <code>var</code> statement declares a local variable within a method.
The scope of local variables is the whole method,
regardless of where in the method they are declared.
In the same method, there can be no more than one declaration for a given variable name.
This is in contrast to variable declarations in JavaScript.  
For example:
<pre class="code">
def average() {
  var avg = (this.x + this.y) / 2.0;
  this.x = avg;
  this.y = avg;
}
</pre>
<p>
defines a local variable called <code>avg</code>, and use the value for <code>x</code> and <code>y</code> properties.  But the following code would raise an error as the variable <code>diff</code> is declared twice:
<pre class="code">
def gcd() {
  if (this.a > this.b) {
    var diff = this.a - this.b;
    this.a = diff;
  } else {
    var diff = this.b - this.a;
    this.b = diff;
  }
</pre>
</p>
<p>
The variable declaration has to be hoisted to outside:
<pre class="code">
def gcd() {
  var diff;
  if (this.a > this.b) {
    diff = this.a - this.b;
    this.a = diff;
  } else {
    diff = this.b - this.a;
    this.b = diff;
  }
</pre>
</p>
<p>
Global variables are declared within static functions, also using the "var" statement.
Global variables are not available to methods, but are visible to all static functions.
For example:
<pre class="code">
static setup() {
  var begin = 1;
}

static loop() {
  if (begin) {
    begin = 0;
  }
}
</pre>
</p>
<p>
The two static functions above refer to the same <code>begin</code> variable.
</p>

<p>
Shadama provides the following built-in global variables:
<ul>
<li> <code>mousemove</code>: an object which has property x and y.</li>
<li> <code>mouseup</code>:  an object which has property x and y.</li>
<li> <code>mousedown</code>: an object which has property x and y.</li>
<li> <code>time</code>:       a floating point value in seconds since the last time a specially named metho setup is called.</li>
<li> <code> width, height</code>: the width and height of the visible 2D space.</li>
</ul>
<p>
In addition to them, there is a variable called <code>Display</code>.
It is a system-defined object, and method invocaton on it causes a
primitive to run.  For example:
<pre class="code">
static loop() {
  Display.clear();
  MyPatch.draw();
}
</pre>
<p>
clears the display area and then draw <code>MyPatch</code>.
</p>
<p>
Be aware that mouse event objects are JavaScript objects. Thus, they can't be passed to methods because
methods can only take scalar arguments.
</p>

<h3 id="parallelism-considerations">Parallelism Considerations</h3>
<p>
It's possible for two or more nearby turtles to write into the same patch cell.
Which value gets stored in the patch is non-deterministic.
</p>
<p>
Also, updates to turtle properties and patch properties are not visible until after the method is run.
Consider the following method:
<pre class="code">
def test() {
  if (this.r > 0) {
     this.r = 0;
  } else {
     this.r = 1; 
  }
  this.b = this.r;
}
</pre>
</p>
<p>
Even though the last line reads "<code>this.b = this.r;</code>", the <code>r</code> property and <code>b</code> property will
not be equal after the invocation. This is because the update to the <code>r</code> property seen earlier does not take effect
until after the method call is finished. Thus, the "b" property will have the previous <code>r</code> value.
</p>

<p>
The properties <code>this.b</code> and <code>this.r</code> can have the same value
through the following use of a local variable:
<pre class="code">
def test() {
  var r = this.r;
  if (r > 0) {
     r = 0;
  } else {
     r = 1; 
  }
  this.r = r;
  this.b = r;
}
</pre>
</p>

<h3 id="control-structures">Control Structures</h3>
<p>
The <code>if</code> statement is the only control structure that Shadama supports.
Loops may be supported in the future version of Shadama because the OpenGL shader language version 3.0
does support variable-count loops.
</p>
<p>

<h3 id="primitive-functions">Primitive Functions</h3>
<p>

There are a number of primitive functions that can be called from methods.
Most of them actually result in a direct call to a GLSL built-in function.
For example:
<pre class="code">
def prims(x) {
  var c = cos(x);
  var s = step(0.5, x);
  var a = abs(x);
  var f = fract(x); // the fraction part of x
  
  this.r = c * s * a * f;
}
</pre>
</p>
<p>
The above code uses several primitive functions to compute a contrived value which
is then stored into the turtle's <code>r</code> property.
</p>

<h3 id="method-binding">Method Binding</h3>
<p> 
Methods are not defined for any particular breed, but a given
method can only be applied to breeds that have the properties referenced
in the method.
For example:
<pre class="code">
breed A (x, r)
breed B (x, y, r, g)
breed C (r)

def set() {
  this.r = 1;
  this.x = 0;
}

static test() {
  A.set();
  B.set();
}
</pre>
</p>
<p>
The <code>set</code> method above can be called for both breed <code>A</code> and breed <code>B</code>.
This is the not the case for breed C because it does not have an <code>x</code> property, which is
referenced in <code>set</code>.
</p>

<h3 id="limitations">Limitations</h3>

<p>
The following are important limitations of the Shadama language.
</p>

<p>
Methods can not take breeds as arguments.
For example, the following code is invalid:
<pre class="code">
breed A (x, y)
breed B (x, y)

def hit(other) {
  var diff = other.x - this.x;
  ...
}

static step() {
  A.hit(B);
}
</pre>
</p>

<p>
The <code>step</code> function passes breed B as an argument to the <code>hit</code> method, which is not allowed.
Even if it were, it is not clear which turtle from breed <code>B</code> should
be bound to the argument <code>other</code>.
</p>

<p>
Another limitation is that a given method can either update the turtle's properties or
the patch's properties, but not both.
For example, the following code is invalid:
<pre class="code">
def test(field) {
  field.r = 1;
  this.r = 1;
}
</pre>
</p>

<p>
This limitation arises from limitations in WebGL itself. Future
versions of WebGL, and thus Shadama, may no longer have this restriction.
In the meantime, a workaround is to split the method into two methods &mdash; one
for updating the patch and one for updating the turtle.
It is also possible that a future version of Shadama will automatically
perform this code transformation.
</p>

</section>

    </article>
  </body>
</html>
